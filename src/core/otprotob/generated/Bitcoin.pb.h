// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: Bitcoin.proto

#pragma once

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3005000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/message_lite.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>   // IWYU pragma: export
// @@protoc_insertion_point(includes)

namespace protobuf_Bitcoin_2eproto
{
// Internal implementation detail -- do not use these members.
struct TableStruct {
    static const ::google::protobuf::internal::ParseTableField entries[];
    static const ::google::protobuf::internal::AuxillaryParseTableField aux[];
    static const ::google::protobuf::internal::ParseTable schema[4];
    static const ::google::protobuf::internal::FieldMetadata field_metadata[];
    static const ::google::protobuf::internal::SerializationTable
        serialization_table[];
    static const ::google::protobuf::uint32 offsets[];
};
void InitDefaultsBitcoinAcct_InternalPBImpl();
void InitDefaultsBitcoinAcct_InternalPB();
void InitDefaultsBitcoinServer_InternalPBImpl();
void InitDefaultsBitcoinServer_InternalPB();
void InitDefaultsRippleServer_InternalPBImpl();
void InitDefaultsRippleServer_InternalPB();
void InitDefaultsLoomServer_InternalPBImpl();
void InitDefaultsLoomServer_InternalPB();
inline void InitDefaults()
{
    InitDefaultsBitcoinAcct_InternalPB();
    InitDefaultsBitcoinServer_InternalPB();
    InitDefaultsRippleServer_InternalPB();
    InitDefaultsLoomServer_InternalPB();
}
}  // namespace protobuf_Bitcoin_2eproto
namespace opentxs
{
namespace OTDB
{
class BitcoinAcct_InternalPB;
class BitcoinAcct_InternalPBDefaultTypeInternal;
extern BitcoinAcct_InternalPBDefaultTypeInternal
    _BitcoinAcct_InternalPB_default_instance_;
class BitcoinServer_InternalPB;
class BitcoinServer_InternalPBDefaultTypeInternal;
extern BitcoinServer_InternalPBDefaultTypeInternal
    _BitcoinServer_InternalPB_default_instance_;
class LoomServer_InternalPB;
class LoomServer_InternalPBDefaultTypeInternal;
extern LoomServer_InternalPBDefaultTypeInternal
    _LoomServer_InternalPB_default_instance_;
class RippleServer_InternalPB;
class RippleServer_InternalPBDefaultTypeInternal;
extern RippleServer_InternalPBDefaultTypeInternal
    _RippleServer_InternalPB_default_instance_;
}  // namespace OTDB
}  // namespace opentxs
namespace opentxs
{
namespace OTDB
{

// ===================================================================

class BitcoinAcct_InternalPB : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:opentxs.OTDB.BitcoinAcct_InternalPB)
                                                                       */
{
public:
    BitcoinAcct_InternalPB();
    virtual ~BitcoinAcct_InternalPB();

    BitcoinAcct_InternalPB(const BitcoinAcct_InternalPB& from);

    inline BitcoinAcct_InternalPB& operator=(const BitcoinAcct_InternalPB& from)
    {
        CopyFrom(from);
        return *this;
    }
#if LANG_CXX11
    BitcoinAcct_InternalPB(BitcoinAcct_InternalPB&& from) noexcept
        : BitcoinAcct_InternalPB()
    {
        *this = ::std::move(from);
    }

    inline BitcoinAcct_InternalPB& operator=(
        BitcoinAcct_InternalPB&& from) noexcept
    {
        if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
            if (this != &from) InternalSwap(&from);
        } else {
            CopyFrom(from);
        }
        return *this;
    }
#endif
    inline const ::std::string& unknown_fields() const
    {
        return _internal_metadata_.unknown_fields();
    }
    inline ::std::string* mutable_unknown_fields()
    {
        return _internal_metadata_.mutable_unknown_fields();
    }

    static const BitcoinAcct_InternalPB& default_instance();

    static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
    static inline const BitcoinAcct_InternalPB* internal_default_instance()
    {
        return reinterpret_cast<const BitcoinAcct_InternalPB*>(
            &_BitcoinAcct_InternalPB_default_instance_);
    }
    static PROTOBUF_CONSTEXPR int const kIndexInFileMessages = 0;

    void Swap(BitcoinAcct_InternalPB* other);
    friend void swap(BitcoinAcct_InternalPB& a, BitcoinAcct_InternalPB& b)
    {
        a.Swap(&b);
    }

    // implements Message ----------------------------------------------

    inline BitcoinAcct_InternalPB* New() const PROTOBUF_FINAL
    {
        return New(NULL);
    }

    BitcoinAcct_InternalPB* New(::google::protobuf::Arena* arena) const
        PROTOBUF_FINAL;
    void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
        PROTOBUF_FINAL;
    void CopyFrom(const BitcoinAcct_InternalPB& from);
    void MergeFrom(const BitcoinAcct_InternalPB& from);
    void Clear() PROTOBUF_FINAL;
    bool IsInitialized() const PROTOBUF_FINAL;

    size_t ByteSizeLong() const PROTOBUF_FINAL;
    bool MergePartialFromCodedStream(
        ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
    void SerializeWithCachedSizes(
        ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
    void DiscardUnknownFields();
    int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }

private:
    void SharedCtor();
    void SharedDtor();
    void SetCachedSize(int size) const;
    void InternalSwap(BitcoinAcct_InternalPB* other);

private:
    inline ::google::protobuf::Arena* GetArenaNoVirtual() const { return NULL; }
    inline void* MaybeArenaPtr() const { return NULL; }

public:
    ::std::string GetTypeName() const PROTOBUF_FINAL;

    // nested types ----------------------------------------------------

    // accessors -------------------------------------------------------

    // optional string gui_label = 1;
    bool has_gui_label() const;
    void clear_gui_label();
    static const int kGuiLabelFieldNumber = 1;
    const ::std::string& gui_label() const;
    void set_gui_label(const ::std::string& value);
#if LANG_CXX11
    void set_gui_label(::std::string&& value);
#endif
    void set_gui_label(const char* value);
    void set_gui_label(const char* value, size_t size);
    ::std::string* mutable_gui_label();
    ::std::string* release_gui_label();
    void set_allocated_gui_label(::std::string* gui_label);

    // optional string notary_id = 2;
    bool has_notary_id() const;
    void clear_notary_id();
    static const int kNotaryIdFieldNumber = 2;
    const ::std::string& notary_id() const;
    void set_notary_id(const ::std::string& value);
#if LANG_CXX11
    void set_notary_id(::std::string&& value);
#endif
    void set_notary_id(const char* value);
    void set_notary_id(const char* value, size_t size);
    ::std::string* mutable_notary_id();
    ::std::string* release_notary_id();
    void set_allocated_notary_id(::std::string* notary_id);

    // optional string acct_id = 3;
    bool has_acct_id() const;
    void clear_acct_id();
    static const int kAcctIdFieldNumber = 3;
    const ::std::string& acct_id() const;
    void set_acct_id(const ::std::string& value);
#if LANG_CXX11
    void set_acct_id(::std::string&& value);
#endif
    void set_acct_id(const char* value);
    void set_acct_id(const char* value, size_t size);
    ::std::string* mutable_acct_id();
    ::std::string* release_acct_id();
    void set_allocated_acct_id(::std::string* acct_id);

    // optional string bitcoin_acct_name = 4;
    bool has_bitcoin_acct_name() const;
    void clear_bitcoin_acct_name();
    static const int kBitcoinAcctNameFieldNumber = 4;
    const ::std::string& bitcoin_acct_name() const;
    void set_bitcoin_acct_name(const ::std::string& value);
#if LANG_CXX11
    void set_bitcoin_acct_name(::std::string&& value);
#endif
    void set_bitcoin_acct_name(const char* value);
    void set_bitcoin_acct_name(const char* value, size_t size);
    ::std::string* mutable_bitcoin_acct_name();
    ::std::string* release_bitcoin_acct_name();
    void set_allocated_bitcoin_acct_name(::std::string* bitcoin_acct_name);

    // @@protoc_insertion_point(class_scope:opentxs.OTDB.BitcoinAcct_InternalPB)
private:
    void set_has_gui_label();
    void clear_has_gui_label();
    void set_has_notary_id();
    void clear_has_notary_id();
    void set_has_acct_id();
    void clear_has_acct_id();
    void set_has_bitcoin_acct_name();
    void clear_has_bitcoin_acct_name();

    ::google::protobuf::internal::InternalMetadataWithArenaLite
        _internal_metadata_;
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable int _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr gui_label_;
    ::google::protobuf::internal::ArenaStringPtr notary_id_;
    ::google::protobuf::internal::ArenaStringPtr acct_id_;
    ::google::protobuf::internal::ArenaStringPtr bitcoin_acct_name_;
    friend struct ::protobuf_Bitcoin_2eproto::TableStruct;
    friend void ::protobuf_Bitcoin_2eproto::
        InitDefaultsBitcoinAcct_InternalPBImpl();
};
// -------------------------------------------------------------------

class BitcoinServer_InternalPB : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:opentxs.OTDB.BitcoinServer_InternalPB)
                                                                         */
{
public:
    BitcoinServer_InternalPB();
    virtual ~BitcoinServer_InternalPB();

    BitcoinServer_InternalPB(const BitcoinServer_InternalPB& from);

    inline BitcoinServer_InternalPB& operator=(
        const BitcoinServer_InternalPB& from)
    {
        CopyFrom(from);
        return *this;
    }
#if LANG_CXX11
    BitcoinServer_InternalPB(BitcoinServer_InternalPB&& from) noexcept
        : BitcoinServer_InternalPB()
    {
        *this = ::std::move(from);
    }

    inline BitcoinServer_InternalPB& operator=(
        BitcoinServer_InternalPB&& from) noexcept
    {
        if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
            if (this != &from) InternalSwap(&from);
        } else {
            CopyFrom(from);
        }
        return *this;
    }
#endif
    inline const ::std::string& unknown_fields() const
    {
        return _internal_metadata_.unknown_fields();
    }
    inline ::std::string* mutable_unknown_fields()
    {
        return _internal_metadata_.mutable_unknown_fields();
    }

    static const BitcoinServer_InternalPB& default_instance();

    static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
    static inline const BitcoinServer_InternalPB* internal_default_instance()
    {
        return reinterpret_cast<const BitcoinServer_InternalPB*>(
            &_BitcoinServer_InternalPB_default_instance_);
    }
    static PROTOBUF_CONSTEXPR int const kIndexInFileMessages = 1;

    void Swap(BitcoinServer_InternalPB* other);
    friend void swap(BitcoinServer_InternalPB& a, BitcoinServer_InternalPB& b)
    {
        a.Swap(&b);
    }

    // implements Message ----------------------------------------------

    inline BitcoinServer_InternalPB* New() const PROTOBUF_FINAL
    {
        return New(NULL);
    }

    BitcoinServer_InternalPB* New(::google::protobuf::Arena* arena) const
        PROTOBUF_FINAL;
    void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
        PROTOBUF_FINAL;
    void CopyFrom(const BitcoinServer_InternalPB& from);
    void MergeFrom(const BitcoinServer_InternalPB& from);
    void Clear() PROTOBUF_FINAL;
    bool IsInitialized() const PROTOBUF_FINAL;

    size_t ByteSizeLong() const PROTOBUF_FINAL;
    bool MergePartialFromCodedStream(
        ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
    void SerializeWithCachedSizes(
        ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
    void DiscardUnknownFields();
    int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }

private:
    void SharedCtor();
    void SharedDtor();
    void SetCachedSize(int size) const;
    void InternalSwap(BitcoinServer_InternalPB* other);

private:
    inline ::google::protobuf::Arena* GetArenaNoVirtual() const { return NULL; }
    inline void* MaybeArenaPtr() const { return NULL; }

public:
    ::std::string GetTypeName() const PROTOBUF_FINAL;

    // nested types ----------------------------------------------------

    // accessors -------------------------------------------------------

    // optional string gui_label = 1;
    bool has_gui_label() const;
    void clear_gui_label();
    static const int kGuiLabelFieldNumber = 1;
    const ::std::string& gui_label() const;
    void set_gui_label(const ::std::string& value);
#if LANG_CXX11
    void set_gui_label(::std::string&& value);
#endif
    void set_gui_label(const char* value);
    void set_gui_label(const char* value, size_t size);
    ::std::string* mutable_gui_label();
    ::std::string* release_gui_label();
    void set_allocated_gui_label(::std::string* gui_label);

    // optional string notary_id = 2;
    bool has_notary_id() const;
    void clear_notary_id();
    static const int kNotaryIdFieldNumber = 2;
    const ::std::string& notary_id() const;
    void set_notary_id(const ::std::string& value);
#if LANG_CXX11
    void set_notary_id(::std::string&& value);
#endif
    void set_notary_id(const char* value);
    void set_notary_id(const char* value, size_t size);
    ::std::string* mutable_notary_id();
    ::std::string* release_notary_id();
    void set_allocated_notary_id(::std::string* notary_id);

    // optional string server_type = 3;
    bool has_server_type() const;
    void clear_server_type();
    static const int kServerTypeFieldNumber = 3;
    const ::std::string& server_type() const;
    void set_server_type(const ::std::string& value);
#if LANG_CXX11
    void set_server_type(::std::string&& value);
#endif
    void set_server_type(const char* value);
    void set_server_type(const char* value, size_t size);
    ::std::string* mutable_server_type();
    ::std::string* release_server_type();
    void set_allocated_server_type(::std::string* server_type);

    // optional string server_host = 4;
    bool has_server_host() const;
    void clear_server_host();
    static const int kServerHostFieldNumber = 4;
    const ::std::string& server_host() const;
    void set_server_host(const ::std::string& value);
#if LANG_CXX11
    void set_server_host(::std::string&& value);
#endif
    void set_server_host(const char* value);
    void set_server_host(const char* value, size_t size);
    ::std::string* mutable_server_host();
    ::std::string* release_server_host();
    void set_allocated_server_host(::std::string* server_host);

    // optional string server_port = 5;
    bool has_server_port() const;
    void clear_server_port();
    static const int kServerPortFieldNumber = 5;
    const ::std::string& server_port() const;
    void set_server_port(const ::std::string& value);
#if LANG_CXX11
    void set_server_port(::std::string&& value);
#endif
    void set_server_port(const char* value);
    void set_server_port(const char* value, size_t size);
    ::std::string* mutable_server_port();
    ::std::string* release_server_port();
    void set_allocated_server_port(::std::string* server_port);

    // optional string bitcoin_username = 6;
    bool has_bitcoin_username() const;
    void clear_bitcoin_username();
    static const int kBitcoinUsernameFieldNumber = 6;
    const ::std::string& bitcoin_username() const;
    void set_bitcoin_username(const ::std::string& value);
#if LANG_CXX11
    void set_bitcoin_username(::std::string&& value);
#endif
    void set_bitcoin_username(const char* value);
    void set_bitcoin_username(const char* value, size_t size);
    ::std::string* mutable_bitcoin_username();
    ::std::string* release_bitcoin_username();
    void set_allocated_bitcoin_username(::std::string* bitcoin_username);

    // optional string bitcoin_password = 7;
    bool has_bitcoin_password() const;
    void clear_bitcoin_password();
    static const int kBitcoinPasswordFieldNumber = 7;
    const ::std::string& bitcoin_password() const;
    void set_bitcoin_password(const ::std::string& value);
#if LANG_CXX11
    void set_bitcoin_password(::std::string&& value);
#endif
    void set_bitcoin_password(const char* value);
    void set_bitcoin_password(const char* value, size_t size);
    ::std::string* mutable_bitcoin_password();
    ::std::string* release_bitcoin_password();
    void set_allocated_bitcoin_password(::std::string* bitcoin_password);

    // @@protoc_insertion_point(class_scope:opentxs.OTDB.BitcoinServer_InternalPB)
private:
    void set_has_gui_label();
    void clear_has_gui_label();
    void set_has_notary_id();
    void clear_has_notary_id();
    void set_has_server_type();
    void clear_has_server_type();
    void set_has_server_host();
    void clear_has_server_host();
    void set_has_server_port();
    void clear_has_server_port();
    void set_has_bitcoin_username();
    void clear_has_bitcoin_username();
    void set_has_bitcoin_password();
    void clear_has_bitcoin_password();

    ::google::protobuf::internal::InternalMetadataWithArenaLite
        _internal_metadata_;
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable int _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr gui_label_;
    ::google::protobuf::internal::ArenaStringPtr notary_id_;
    ::google::protobuf::internal::ArenaStringPtr server_type_;
    ::google::protobuf::internal::ArenaStringPtr server_host_;
    ::google::protobuf::internal::ArenaStringPtr server_port_;
    ::google::protobuf::internal::ArenaStringPtr bitcoin_username_;
    ::google::protobuf::internal::ArenaStringPtr bitcoin_password_;
    friend struct ::protobuf_Bitcoin_2eproto::TableStruct;
    friend void ::protobuf_Bitcoin_2eproto::
        InitDefaultsBitcoinServer_InternalPBImpl();
};
// -------------------------------------------------------------------

class RippleServer_InternalPB : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:opentxs.OTDB.RippleServer_InternalPB)
                                                                        */
{
public:
    RippleServer_InternalPB();
    virtual ~RippleServer_InternalPB();

    RippleServer_InternalPB(const RippleServer_InternalPB& from);

    inline RippleServer_InternalPB& operator=(
        const RippleServer_InternalPB& from)
    {
        CopyFrom(from);
        return *this;
    }
#if LANG_CXX11
    RippleServer_InternalPB(RippleServer_InternalPB&& from) noexcept
        : RippleServer_InternalPB()
    {
        *this = ::std::move(from);
    }

    inline RippleServer_InternalPB& operator=(
        RippleServer_InternalPB&& from) noexcept
    {
        if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
            if (this != &from) InternalSwap(&from);
        } else {
            CopyFrom(from);
        }
        return *this;
    }
#endif
    inline const ::std::string& unknown_fields() const
    {
        return _internal_metadata_.unknown_fields();
    }
    inline ::std::string* mutable_unknown_fields()
    {
        return _internal_metadata_.mutable_unknown_fields();
    }

    static const RippleServer_InternalPB& default_instance();

    static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
    static inline const RippleServer_InternalPB* internal_default_instance()
    {
        return reinterpret_cast<const RippleServer_InternalPB*>(
            &_RippleServer_InternalPB_default_instance_);
    }
    static PROTOBUF_CONSTEXPR int const kIndexInFileMessages = 2;

    void Swap(RippleServer_InternalPB* other);
    friend void swap(RippleServer_InternalPB& a, RippleServer_InternalPB& b)
    {
        a.Swap(&b);
    }

    // implements Message ----------------------------------------------

    inline RippleServer_InternalPB* New() const PROTOBUF_FINAL
    {
        return New(NULL);
    }

    RippleServer_InternalPB* New(::google::protobuf::Arena* arena) const
        PROTOBUF_FINAL;
    void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
        PROTOBUF_FINAL;
    void CopyFrom(const RippleServer_InternalPB& from);
    void MergeFrom(const RippleServer_InternalPB& from);
    void Clear() PROTOBUF_FINAL;
    bool IsInitialized() const PROTOBUF_FINAL;

    size_t ByteSizeLong() const PROTOBUF_FINAL;
    bool MergePartialFromCodedStream(
        ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
    void SerializeWithCachedSizes(
        ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
    void DiscardUnknownFields();
    int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }

private:
    void SharedCtor();
    void SharedDtor();
    void SetCachedSize(int size) const;
    void InternalSwap(RippleServer_InternalPB* other);

private:
    inline ::google::protobuf::Arena* GetArenaNoVirtual() const { return NULL; }
    inline void* MaybeArenaPtr() const { return NULL; }

public:
    ::std::string GetTypeName() const PROTOBUF_FINAL;

    // nested types ----------------------------------------------------

    // accessors -------------------------------------------------------

    // optional string gui_label = 1;
    bool has_gui_label() const;
    void clear_gui_label();
    static const int kGuiLabelFieldNumber = 1;
    const ::std::string& gui_label() const;
    void set_gui_label(const ::std::string& value);
#if LANG_CXX11
    void set_gui_label(::std::string&& value);
#endif
    void set_gui_label(const char* value);
    void set_gui_label(const char* value, size_t size);
    ::std::string* mutable_gui_label();
    ::std::string* release_gui_label();
    void set_allocated_gui_label(::std::string* gui_label);

    // optional string notary_id = 2;
    bool has_notary_id() const;
    void clear_notary_id();
    static const int kNotaryIdFieldNumber = 2;
    const ::std::string& notary_id() const;
    void set_notary_id(const ::std::string& value);
#if LANG_CXX11
    void set_notary_id(::std::string&& value);
#endif
    void set_notary_id(const char* value);
    void set_notary_id(const char* value, size_t size);
    ::std::string* mutable_notary_id();
    ::std::string* release_notary_id();
    void set_allocated_notary_id(::std::string* notary_id);

    // optional string server_type = 3;
    bool has_server_type() const;
    void clear_server_type();
    static const int kServerTypeFieldNumber = 3;
    const ::std::string& server_type() const;
    void set_server_type(const ::std::string& value);
#if LANG_CXX11
    void set_server_type(::std::string&& value);
#endif
    void set_server_type(const char* value);
    void set_server_type(const char* value, size_t size);
    ::std::string* mutable_server_type();
    ::std::string* release_server_type();
    void set_allocated_server_type(::std::string* server_type);

    // optional string server_host = 4;
    bool has_server_host() const;
    void clear_server_host();
    static const int kServerHostFieldNumber = 4;
    const ::std::string& server_host() const;
    void set_server_host(const ::std::string& value);
#if LANG_CXX11
    void set_server_host(::std::string&& value);
#endif
    void set_server_host(const char* value);
    void set_server_host(const char* value, size_t size);
    ::std::string* mutable_server_host();
    ::std::string* release_server_host();
    void set_allocated_server_host(::std::string* server_host);

    // optional string server_port = 5;
    bool has_server_port() const;
    void clear_server_port();
    static const int kServerPortFieldNumber = 5;
    const ::std::string& server_port() const;
    void set_server_port(const ::std::string& value);
#if LANG_CXX11
    void set_server_port(::std::string&& value);
#endif
    void set_server_port(const char* value);
    void set_server_port(const char* value, size_t size);
    ::std::string* mutable_server_port();
    ::std::string* release_server_port();
    void set_allocated_server_port(::std::string* server_port);

    // optional string ripple_username = 6;
    bool has_ripple_username() const;
    void clear_ripple_username();
    static const int kRippleUsernameFieldNumber = 6;
    const ::std::string& ripple_username() const;
    void set_ripple_username(const ::std::string& value);
#if LANG_CXX11
    void set_ripple_username(::std::string&& value);
#endif
    void set_ripple_username(const char* value);
    void set_ripple_username(const char* value, size_t size);
    ::std::string* mutable_ripple_username();
    ::std::string* release_ripple_username();
    void set_allocated_ripple_username(::std::string* ripple_username);

    // optional string ripple_password = 7;
    bool has_ripple_password() const;
    void clear_ripple_password();
    static const int kRipplePasswordFieldNumber = 7;
    const ::std::string& ripple_password() const;
    void set_ripple_password(const ::std::string& value);
#if LANG_CXX11
    void set_ripple_password(::std::string&& value);
#endif
    void set_ripple_password(const char* value);
    void set_ripple_password(const char* value, size_t size);
    ::std::string* mutable_ripple_password();
    ::std::string* release_ripple_password();
    void set_allocated_ripple_password(::std::string* ripple_password);

    // optional string namefield_id = 8;
    bool has_namefield_id() const;
    void clear_namefield_id();
    static const int kNamefieldIdFieldNumber = 8;
    const ::std::string& namefield_id() const;
    void set_namefield_id(const ::std::string& value);
#if LANG_CXX11
    void set_namefield_id(::std::string&& value);
#endif
    void set_namefield_id(const char* value);
    void set_namefield_id(const char* value, size_t size);
    ::std::string* mutable_namefield_id();
    ::std::string* release_namefield_id();
    void set_allocated_namefield_id(::std::string* namefield_id);

    // optional string passfield_id = 9;
    bool has_passfield_id() const;
    void clear_passfield_id();
    static const int kPassfieldIdFieldNumber = 9;
    const ::std::string& passfield_id() const;
    void set_passfield_id(const ::std::string& value);
#if LANG_CXX11
    void set_passfield_id(::std::string&& value);
#endif
    void set_passfield_id(const char* value);
    void set_passfield_id(const char* value, size_t size);
    ::std::string* mutable_passfield_id();
    ::std::string* release_passfield_id();
    void set_allocated_passfield_id(::std::string* passfield_id);

    // @@protoc_insertion_point(class_scope:opentxs.OTDB.RippleServer_InternalPB)
private:
    void set_has_gui_label();
    void clear_has_gui_label();
    void set_has_notary_id();
    void clear_has_notary_id();
    void set_has_server_type();
    void clear_has_server_type();
    void set_has_server_host();
    void clear_has_server_host();
    void set_has_server_port();
    void clear_has_server_port();
    void set_has_ripple_username();
    void clear_has_ripple_username();
    void set_has_ripple_password();
    void clear_has_ripple_password();
    void set_has_namefield_id();
    void clear_has_namefield_id();
    void set_has_passfield_id();
    void clear_has_passfield_id();

    ::google::protobuf::internal::InternalMetadataWithArenaLite
        _internal_metadata_;
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable int _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr gui_label_;
    ::google::protobuf::internal::ArenaStringPtr notary_id_;
    ::google::protobuf::internal::ArenaStringPtr server_type_;
    ::google::protobuf::internal::ArenaStringPtr server_host_;
    ::google::protobuf::internal::ArenaStringPtr server_port_;
    ::google::protobuf::internal::ArenaStringPtr ripple_username_;
    ::google::protobuf::internal::ArenaStringPtr ripple_password_;
    ::google::protobuf::internal::ArenaStringPtr namefield_id_;
    ::google::protobuf::internal::ArenaStringPtr passfield_id_;
    friend struct ::protobuf_Bitcoin_2eproto::TableStruct;
    friend void ::protobuf_Bitcoin_2eproto::
        InitDefaultsRippleServer_InternalPBImpl();
};
// -------------------------------------------------------------------

class LoomServer_InternalPB : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:opentxs.OTDB.LoomServer_InternalPB)
                                                                      */
{
public:
    LoomServer_InternalPB();
    virtual ~LoomServer_InternalPB();

    LoomServer_InternalPB(const LoomServer_InternalPB& from);

    inline LoomServer_InternalPB& operator=(const LoomServer_InternalPB& from)
    {
        CopyFrom(from);
        return *this;
    }
#if LANG_CXX11
    LoomServer_InternalPB(LoomServer_InternalPB&& from) noexcept
        : LoomServer_InternalPB()
    {
        *this = ::std::move(from);
    }

    inline LoomServer_InternalPB& operator=(
        LoomServer_InternalPB&& from) noexcept
    {
        if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
            if (this != &from) InternalSwap(&from);
        } else {
            CopyFrom(from);
        }
        return *this;
    }
#endif
    inline const ::std::string& unknown_fields() const
    {
        return _internal_metadata_.unknown_fields();
    }
    inline ::std::string* mutable_unknown_fields()
    {
        return _internal_metadata_.mutable_unknown_fields();
    }

    static const LoomServer_InternalPB& default_instance();

    static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
    static inline const LoomServer_InternalPB* internal_default_instance()
    {
        return reinterpret_cast<const LoomServer_InternalPB*>(
            &_LoomServer_InternalPB_default_instance_);
    }
    static PROTOBUF_CONSTEXPR int const kIndexInFileMessages = 3;

    void Swap(LoomServer_InternalPB* other);
    friend void swap(LoomServer_InternalPB& a, LoomServer_InternalPB& b)
    {
        a.Swap(&b);
    }

    // implements Message ----------------------------------------------

    inline LoomServer_InternalPB* New() const PROTOBUF_FINAL
    {
        return New(NULL);
    }

    LoomServer_InternalPB* New(::google::protobuf::Arena* arena) const
        PROTOBUF_FINAL;
    void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
        PROTOBUF_FINAL;
    void CopyFrom(const LoomServer_InternalPB& from);
    void MergeFrom(const LoomServer_InternalPB& from);
    void Clear() PROTOBUF_FINAL;
    bool IsInitialized() const PROTOBUF_FINAL;

    size_t ByteSizeLong() const PROTOBUF_FINAL;
    bool MergePartialFromCodedStream(
        ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
    void SerializeWithCachedSizes(
        ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
    void DiscardUnknownFields();
    int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }

private:
    void SharedCtor();
    void SharedDtor();
    void SetCachedSize(int size) const;
    void InternalSwap(LoomServer_InternalPB* other);

private:
    inline ::google::protobuf::Arena* GetArenaNoVirtual() const { return NULL; }
    inline void* MaybeArenaPtr() const { return NULL; }

public:
    ::std::string GetTypeName() const PROTOBUF_FINAL;

    // nested types ----------------------------------------------------

    // accessors -------------------------------------------------------

    // optional string gui_label = 1;
    bool has_gui_label() const;
    void clear_gui_label();
    static const int kGuiLabelFieldNumber = 1;
    const ::std::string& gui_label() const;
    void set_gui_label(const ::std::string& value);
#if LANG_CXX11
    void set_gui_label(::std::string&& value);
#endif
    void set_gui_label(const char* value);
    void set_gui_label(const char* value, size_t size);
    ::std::string* mutable_gui_label();
    ::std::string* release_gui_label();
    void set_allocated_gui_label(::std::string* gui_label);

    // optional string notary_id = 2;
    bool has_notary_id() const;
    void clear_notary_id();
    static const int kNotaryIdFieldNumber = 2;
    const ::std::string& notary_id() const;
    void set_notary_id(const ::std::string& value);
#if LANG_CXX11
    void set_notary_id(::std::string&& value);
#endif
    void set_notary_id(const char* value);
    void set_notary_id(const char* value, size_t size);
    ::std::string* mutable_notary_id();
    ::std::string* release_notary_id();
    void set_allocated_notary_id(::std::string* notary_id);

    // optional string server_type = 3;
    bool has_server_type() const;
    void clear_server_type();
    static const int kServerTypeFieldNumber = 3;
    const ::std::string& server_type() const;
    void set_server_type(const ::std::string& value);
#if LANG_CXX11
    void set_server_type(::std::string&& value);
#endif
    void set_server_type(const char* value);
    void set_server_type(const char* value, size_t size);
    ::std::string* mutable_server_type();
    ::std::string* release_server_type();
    void set_allocated_server_type(::std::string* server_type);

    // optional string server_host = 4;
    bool has_server_host() const;
    void clear_server_host();
    static const int kServerHostFieldNumber = 4;
    const ::std::string& server_host() const;
    void set_server_host(const ::std::string& value);
#if LANG_CXX11
    void set_server_host(::std::string&& value);
#endif
    void set_server_host(const char* value);
    void set_server_host(const char* value, size_t size);
    ::std::string* mutable_server_host();
    ::std::string* release_server_host();
    void set_allocated_server_host(::std::string* server_host);

    // optional string server_port = 5;
    bool has_server_port() const;
    void clear_server_port();
    static const int kServerPortFieldNumber = 5;
    const ::std::string& server_port() const;
    void set_server_port(const ::std::string& value);
#if LANG_CXX11
    void set_server_port(::std::string&& value);
#endif
    void set_server_port(const char* value);
    void set_server_port(const char* value, size_t size);
    ::std::string* mutable_server_port();
    ::std::string* release_server_port();
    void set_allocated_server_port(::std::string* server_port);

    // optional string loom_username = 6;
    bool has_loom_username() const;
    void clear_loom_username();
    static const int kLoomUsernameFieldNumber = 6;
    const ::std::string& loom_username() const;
    void set_loom_username(const ::std::string& value);
#if LANG_CXX11
    void set_loom_username(::std::string&& value);
#endif
    void set_loom_username(const char* value);
    void set_loom_username(const char* value, size_t size);
    ::std::string* mutable_loom_username();
    ::std::string* release_loom_username();
    void set_allocated_loom_username(::std::string* loom_username);

    // optional string namefield_id = 7;
    bool has_namefield_id() const;
    void clear_namefield_id();
    static const int kNamefieldIdFieldNumber = 7;
    const ::std::string& namefield_id() const;
    void set_namefield_id(const ::std::string& value);
#if LANG_CXX11
    void set_namefield_id(::std::string&& value);
#endif
    void set_namefield_id(const char* value);
    void set_namefield_id(const char* value, size_t size);
    ::std::string* mutable_namefield_id();
    ::std::string* release_namefield_id();
    void set_allocated_namefield_id(::std::string* namefield_id);

    // @@protoc_insertion_point(class_scope:opentxs.OTDB.LoomServer_InternalPB)
private:
    void set_has_gui_label();
    void clear_has_gui_label();
    void set_has_notary_id();
    void clear_has_notary_id();
    void set_has_server_type();
    void clear_has_server_type();
    void set_has_server_host();
    void clear_has_server_host();
    void set_has_server_port();
    void clear_has_server_port();
    void set_has_loom_username();
    void clear_has_loom_username();
    void set_has_namefield_id();
    void clear_has_namefield_id();

    ::google::protobuf::internal::InternalMetadataWithArenaLite
        _internal_metadata_;
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable int _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr gui_label_;
    ::google::protobuf::internal::ArenaStringPtr notary_id_;
    ::google::protobuf::internal::ArenaStringPtr server_type_;
    ::google::protobuf::internal::ArenaStringPtr server_host_;
    ::google::protobuf::internal::ArenaStringPtr server_port_;
    ::google::protobuf::internal::ArenaStringPtr loom_username_;
    ::google::protobuf::internal::ArenaStringPtr namefield_id_;
    friend struct ::protobuf_Bitcoin_2eproto::TableStruct;
    friend void ::protobuf_Bitcoin_2eproto::
        InitDefaultsLoomServer_InternalPBImpl();
};
// ===================================================================

// ===================================================================

#ifdef __GNUC__
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// BitcoinAcct_InternalPB

// optional string gui_label = 1;
inline bool BitcoinAcct_InternalPB::has_gui_label() const
{
    return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void BitcoinAcct_InternalPB::set_has_gui_label()
{
    _has_bits_[0] |= 0x00000001u;
}
inline void BitcoinAcct_InternalPB::clear_has_gui_label()
{
    _has_bits_[0] &= ~0x00000001u;
}
inline void BitcoinAcct_InternalPB::clear_gui_label()
{
    gui_label_.ClearToEmptyNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
    clear_has_gui_label();
}
inline const ::std::string& BitcoinAcct_InternalPB::gui_label() const
{
    // @@protoc_insertion_point(field_get:opentxs.OTDB.BitcoinAcct_InternalPB.gui_label)
    return gui_label_.GetNoArena();
}
inline void BitcoinAcct_InternalPB::set_gui_label(const ::std::string& value)
{
    set_has_gui_label();
    gui_label_.SetNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
    // @@protoc_insertion_point(field_set:opentxs.OTDB.BitcoinAcct_InternalPB.gui_label)
}
#if LANG_CXX11
inline void BitcoinAcct_InternalPB::set_gui_label(::std::string&& value)
{
    set_has_gui_label();
    gui_label_.SetNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited(),
        ::std::move(value));
    // @@protoc_insertion_point(field_set_rvalue:opentxs.OTDB.BitcoinAcct_InternalPB.gui_label)
}
#endif
inline void BitcoinAcct_InternalPB::set_gui_label(const char* value)
{
    GOOGLE_DCHECK(value != NULL);
    set_has_gui_label();
    gui_label_.SetNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited(),
        ::std::string(value));
    // @@protoc_insertion_point(field_set_char:opentxs.OTDB.BitcoinAcct_InternalPB.gui_label)
}
inline void BitcoinAcct_InternalPB::set_gui_label(
    const char* value,
    size_t size)
{
    set_has_gui_label();
    gui_label_.SetNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited(),
        ::std::string(reinterpret_cast<const char*>(value), size));
    // @@protoc_insertion_point(field_set_pointer:opentxs.OTDB.BitcoinAcct_InternalPB.gui_label)
}
inline ::std::string* BitcoinAcct_InternalPB::mutable_gui_label()
{
    set_has_gui_label();
    // @@protoc_insertion_point(field_mutable:opentxs.OTDB.BitcoinAcct_InternalPB.gui_label)
    return gui_label_.MutableNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* BitcoinAcct_InternalPB::release_gui_label()
{
    // @@protoc_insertion_point(field_release:opentxs.OTDB.BitcoinAcct_InternalPB.gui_label)
    clear_has_gui_label();
    return gui_label_.ReleaseNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void BitcoinAcct_InternalPB::set_allocated_gui_label(
    ::std::string* gui_label)
{
    if (gui_label != NULL) {
        set_has_gui_label();
    } else {
        clear_has_gui_label();
    }
    gui_label_.SetAllocatedNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited(),
        gui_label);
    // @@protoc_insertion_point(field_set_allocated:opentxs.OTDB.BitcoinAcct_InternalPB.gui_label)
}

// optional string notary_id = 2;
inline bool BitcoinAcct_InternalPB::has_notary_id() const
{
    return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void BitcoinAcct_InternalPB::set_has_notary_id()
{
    _has_bits_[0] |= 0x00000002u;
}
inline void BitcoinAcct_InternalPB::clear_has_notary_id()
{
    _has_bits_[0] &= ~0x00000002u;
}
inline void BitcoinAcct_InternalPB::clear_notary_id()
{
    notary_id_.ClearToEmptyNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
    clear_has_notary_id();
}
inline const ::std::string& BitcoinAcct_InternalPB::notary_id() const
{
    // @@protoc_insertion_point(field_get:opentxs.OTDB.BitcoinAcct_InternalPB.notary_id)
    return notary_id_.GetNoArena();
}
inline void BitcoinAcct_InternalPB::set_notary_id(const ::std::string& value)
{
    set_has_notary_id();
    notary_id_.SetNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
    // @@protoc_insertion_point(field_set:opentxs.OTDB.BitcoinAcct_InternalPB.notary_id)
}
#if LANG_CXX11
inline void BitcoinAcct_InternalPB::set_notary_id(::std::string&& value)
{
    set_has_notary_id();
    notary_id_.SetNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited(),
        ::std::move(value));
    // @@protoc_insertion_point(field_set_rvalue:opentxs.OTDB.BitcoinAcct_InternalPB.notary_id)
}
#endif
inline void BitcoinAcct_InternalPB::set_notary_id(const char* value)
{
    GOOGLE_DCHECK(value != NULL);
    set_has_notary_id();
    notary_id_.SetNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited(),
        ::std::string(value));
    // @@protoc_insertion_point(field_set_char:opentxs.OTDB.BitcoinAcct_InternalPB.notary_id)
}
inline void BitcoinAcct_InternalPB::set_notary_id(
    const char* value,
    size_t size)
{
    set_has_notary_id();
    notary_id_.SetNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited(),
        ::std::string(reinterpret_cast<const char*>(value), size));
    // @@protoc_insertion_point(field_set_pointer:opentxs.OTDB.BitcoinAcct_InternalPB.notary_id)
}
inline ::std::string* BitcoinAcct_InternalPB::mutable_notary_id()
{
    set_has_notary_id();
    // @@protoc_insertion_point(field_mutable:opentxs.OTDB.BitcoinAcct_InternalPB.notary_id)
    return notary_id_.MutableNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* BitcoinAcct_InternalPB::release_notary_id()
{
    // @@protoc_insertion_point(field_release:opentxs.OTDB.BitcoinAcct_InternalPB.notary_id)
    clear_has_notary_id();
    return notary_id_.ReleaseNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void BitcoinAcct_InternalPB::set_allocated_notary_id(
    ::std::string* notary_id)
{
    if (notary_id != NULL) {
        set_has_notary_id();
    } else {
        clear_has_notary_id();
    }
    notary_id_.SetAllocatedNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited(),
        notary_id);
    // @@protoc_insertion_point(field_set_allocated:opentxs.OTDB.BitcoinAcct_InternalPB.notary_id)
}

// optional string acct_id = 3;
inline bool BitcoinAcct_InternalPB::has_acct_id() const
{
    return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void BitcoinAcct_InternalPB::set_has_acct_id()
{
    _has_bits_[0] |= 0x00000004u;
}
inline void BitcoinAcct_InternalPB::clear_has_acct_id()
{
    _has_bits_[0] &= ~0x00000004u;
}
inline void BitcoinAcct_InternalPB::clear_acct_id()
{
    acct_id_.ClearToEmptyNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
    clear_has_acct_id();
}
inline const ::std::string& BitcoinAcct_InternalPB::acct_id() const
{
    // @@protoc_insertion_point(field_get:opentxs.OTDB.BitcoinAcct_InternalPB.acct_id)
    return acct_id_.GetNoArena();
}
inline void BitcoinAcct_InternalPB::set_acct_id(const ::std::string& value)
{
    set_has_acct_id();
    acct_id_.SetNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
    // @@protoc_insertion_point(field_set:opentxs.OTDB.BitcoinAcct_InternalPB.acct_id)
}
#if LANG_CXX11
inline void BitcoinAcct_InternalPB::set_acct_id(::std::string&& value)
{
    set_has_acct_id();
    acct_id_.SetNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited(),
        ::std::move(value));
    // @@protoc_insertion_point(field_set_rvalue:opentxs.OTDB.BitcoinAcct_InternalPB.acct_id)
}
#endif
inline void BitcoinAcct_InternalPB::set_acct_id(const char* value)
{
    GOOGLE_DCHECK(value != NULL);
    set_has_acct_id();
    acct_id_.SetNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited(),
        ::std::string(value));
    // @@protoc_insertion_point(field_set_char:opentxs.OTDB.BitcoinAcct_InternalPB.acct_id)
}
inline void BitcoinAcct_InternalPB::set_acct_id(const char* value, size_t size)
{
    set_has_acct_id();
    acct_id_.SetNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited(),
        ::std::string(reinterpret_cast<const char*>(value), size));
    // @@protoc_insertion_point(field_set_pointer:opentxs.OTDB.BitcoinAcct_InternalPB.acct_id)
}
inline ::std::string* BitcoinAcct_InternalPB::mutable_acct_id()
{
    set_has_acct_id();
    // @@protoc_insertion_point(field_mutable:opentxs.OTDB.BitcoinAcct_InternalPB.acct_id)
    return acct_id_.MutableNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* BitcoinAcct_InternalPB::release_acct_id()
{
    // @@protoc_insertion_point(field_release:opentxs.OTDB.BitcoinAcct_InternalPB.acct_id)
    clear_has_acct_id();
    return acct_id_.ReleaseNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void BitcoinAcct_InternalPB::set_allocated_acct_id(
    ::std::string* acct_id)
{
    if (acct_id != NULL) {
        set_has_acct_id();
    } else {
        clear_has_acct_id();
    }
    acct_id_.SetAllocatedNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited(), acct_id);
    // @@protoc_insertion_point(field_set_allocated:opentxs.OTDB.BitcoinAcct_InternalPB.acct_id)
}

// optional string bitcoin_acct_name = 4;
inline bool BitcoinAcct_InternalPB::has_bitcoin_acct_name() const
{
    return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void BitcoinAcct_InternalPB::set_has_bitcoin_acct_name()
{
    _has_bits_[0] |= 0x00000008u;
}
inline void BitcoinAcct_InternalPB::clear_has_bitcoin_acct_name()
{
    _has_bits_[0] &= ~0x00000008u;
}
inline void BitcoinAcct_InternalPB::clear_bitcoin_acct_name()
{
    bitcoin_acct_name_.ClearToEmptyNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
    clear_has_bitcoin_acct_name();
}
inline const ::std::string& BitcoinAcct_InternalPB::bitcoin_acct_name() const
{
    // @@protoc_insertion_point(field_get:opentxs.OTDB.BitcoinAcct_InternalPB.bitcoin_acct_name)
    return bitcoin_acct_name_.GetNoArena();
}
inline void BitcoinAcct_InternalPB::set_bitcoin_acct_name(
    const ::std::string& value)
{
    set_has_bitcoin_acct_name();
    bitcoin_acct_name_.SetNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
    // @@protoc_insertion_point(field_set:opentxs.OTDB.BitcoinAcct_InternalPB.bitcoin_acct_name)
}
#if LANG_CXX11
inline void BitcoinAcct_InternalPB::set_bitcoin_acct_name(::std::string&& value)
{
    set_has_bitcoin_acct_name();
    bitcoin_acct_name_.SetNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited(),
        ::std::move(value));
    // @@protoc_insertion_point(field_set_rvalue:opentxs.OTDB.BitcoinAcct_InternalPB.bitcoin_acct_name)
}
#endif
inline void BitcoinAcct_InternalPB::set_bitcoin_acct_name(const char* value)
{
    GOOGLE_DCHECK(value != NULL);
    set_has_bitcoin_acct_name();
    bitcoin_acct_name_.SetNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited(),
        ::std::string(value));
    // @@protoc_insertion_point(field_set_char:opentxs.OTDB.BitcoinAcct_InternalPB.bitcoin_acct_name)
}
inline void BitcoinAcct_InternalPB::set_bitcoin_acct_name(
    const char* value,
    size_t size)
{
    set_has_bitcoin_acct_name();
    bitcoin_acct_name_.SetNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited(),
        ::std::string(reinterpret_cast<const char*>(value), size));
    // @@protoc_insertion_point(field_set_pointer:opentxs.OTDB.BitcoinAcct_InternalPB.bitcoin_acct_name)
}
inline ::std::string* BitcoinAcct_InternalPB::mutable_bitcoin_acct_name()
{
    set_has_bitcoin_acct_name();
    // @@protoc_insertion_point(field_mutable:opentxs.OTDB.BitcoinAcct_InternalPB.bitcoin_acct_name)
    return bitcoin_acct_name_.MutableNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* BitcoinAcct_InternalPB::release_bitcoin_acct_name()
{
    // @@protoc_insertion_point(field_release:opentxs.OTDB.BitcoinAcct_InternalPB.bitcoin_acct_name)
    clear_has_bitcoin_acct_name();
    return bitcoin_acct_name_.ReleaseNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void BitcoinAcct_InternalPB::set_allocated_bitcoin_acct_name(
    ::std::string* bitcoin_acct_name)
{
    if (bitcoin_acct_name != NULL) {
        set_has_bitcoin_acct_name();
    } else {
        clear_has_bitcoin_acct_name();
    }
    bitcoin_acct_name_.SetAllocatedNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited(),
        bitcoin_acct_name);
    // @@protoc_insertion_point(field_set_allocated:opentxs.OTDB.BitcoinAcct_InternalPB.bitcoin_acct_name)
}

// -------------------------------------------------------------------

// BitcoinServer_InternalPB

// optional string gui_label = 1;
inline bool BitcoinServer_InternalPB::has_gui_label() const
{
    return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void BitcoinServer_InternalPB::set_has_gui_label()
{
    _has_bits_[0] |= 0x00000001u;
}
inline void BitcoinServer_InternalPB::clear_has_gui_label()
{
    _has_bits_[0] &= ~0x00000001u;
}
inline void BitcoinServer_InternalPB::clear_gui_label()
{
    gui_label_.ClearToEmptyNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
    clear_has_gui_label();
}
inline const ::std::string& BitcoinServer_InternalPB::gui_label() const
{
    // @@protoc_insertion_point(field_get:opentxs.OTDB.BitcoinServer_InternalPB.gui_label)
    return gui_label_.GetNoArena();
}
inline void BitcoinServer_InternalPB::set_gui_label(const ::std::string& value)
{
    set_has_gui_label();
    gui_label_.SetNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
    // @@protoc_insertion_point(field_set:opentxs.OTDB.BitcoinServer_InternalPB.gui_label)
}
#if LANG_CXX11
inline void BitcoinServer_InternalPB::set_gui_label(::std::string&& value)
{
    set_has_gui_label();
    gui_label_.SetNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited(),
        ::std::move(value));
    // @@protoc_insertion_point(field_set_rvalue:opentxs.OTDB.BitcoinServer_InternalPB.gui_label)
}
#endif
inline void BitcoinServer_InternalPB::set_gui_label(const char* value)
{
    GOOGLE_DCHECK(value != NULL);
    set_has_gui_label();
    gui_label_.SetNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited(),
        ::std::string(value));
    // @@protoc_insertion_point(field_set_char:opentxs.OTDB.BitcoinServer_InternalPB.gui_label)
}
inline void BitcoinServer_InternalPB::set_gui_label(
    const char* value,
    size_t size)
{
    set_has_gui_label();
    gui_label_.SetNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited(),
        ::std::string(reinterpret_cast<const char*>(value), size));
    // @@protoc_insertion_point(field_set_pointer:opentxs.OTDB.BitcoinServer_InternalPB.gui_label)
}
inline ::std::string* BitcoinServer_InternalPB::mutable_gui_label()
{
    set_has_gui_label();
    // @@protoc_insertion_point(field_mutable:opentxs.OTDB.BitcoinServer_InternalPB.gui_label)
    return gui_label_.MutableNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* BitcoinServer_InternalPB::release_gui_label()
{
    // @@protoc_insertion_point(field_release:opentxs.OTDB.BitcoinServer_InternalPB.gui_label)
    clear_has_gui_label();
    return gui_label_.ReleaseNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void BitcoinServer_InternalPB::set_allocated_gui_label(
    ::std::string* gui_label)
{
    if (gui_label != NULL) {
        set_has_gui_label();
    } else {
        clear_has_gui_label();
    }
    gui_label_.SetAllocatedNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited(),
        gui_label);
    // @@protoc_insertion_point(field_set_allocated:opentxs.OTDB.BitcoinServer_InternalPB.gui_label)
}

// optional string notary_id = 2;
inline bool BitcoinServer_InternalPB::has_notary_id() const
{
    return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void BitcoinServer_InternalPB::set_has_notary_id()
{
    _has_bits_[0] |= 0x00000002u;
}
inline void BitcoinServer_InternalPB::clear_has_notary_id()
{
    _has_bits_[0] &= ~0x00000002u;
}
inline void BitcoinServer_InternalPB::clear_notary_id()
{
    notary_id_.ClearToEmptyNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
    clear_has_notary_id();
}
inline const ::std::string& BitcoinServer_InternalPB::notary_id() const
{
    // @@protoc_insertion_point(field_get:opentxs.OTDB.BitcoinServer_InternalPB.notary_id)
    return notary_id_.GetNoArena();
}
inline void BitcoinServer_InternalPB::set_notary_id(const ::std::string& value)
{
    set_has_notary_id();
    notary_id_.SetNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
    // @@protoc_insertion_point(field_set:opentxs.OTDB.BitcoinServer_InternalPB.notary_id)
}
#if LANG_CXX11
inline void BitcoinServer_InternalPB::set_notary_id(::std::string&& value)
{
    set_has_notary_id();
    notary_id_.SetNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited(),
        ::std::move(value));
    // @@protoc_insertion_point(field_set_rvalue:opentxs.OTDB.BitcoinServer_InternalPB.notary_id)
}
#endif
inline void BitcoinServer_InternalPB::set_notary_id(const char* value)
{
    GOOGLE_DCHECK(value != NULL);
    set_has_notary_id();
    notary_id_.SetNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited(),
        ::std::string(value));
    // @@protoc_insertion_point(field_set_char:opentxs.OTDB.BitcoinServer_InternalPB.notary_id)
}
inline void BitcoinServer_InternalPB::set_notary_id(
    const char* value,
    size_t size)
{
    set_has_notary_id();
    notary_id_.SetNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited(),
        ::std::string(reinterpret_cast<const char*>(value), size));
    // @@protoc_insertion_point(field_set_pointer:opentxs.OTDB.BitcoinServer_InternalPB.notary_id)
}
inline ::std::string* BitcoinServer_InternalPB::mutable_notary_id()
{
    set_has_notary_id();
    // @@protoc_insertion_point(field_mutable:opentxs.OTDB.BitcoinServer_InternalPB.notary_id)
    return notary_id_.MutableNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* BitcoinServer_InternalPB::release_notary_id()
{
    // @@protoc_insertion_point(field_release:opentxs.OTDB.BitcoinServer_InternalPB.notary_id)
    clear_has_notary_id();
    return notary_id_.ReleaseNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void BitcoinServer_InternalPB::set_allocated_notary_id(
    ::std::string* notary_id)
{
    if (notary_id != NULL) {
        set_has_notary_id();
    } else {
        clear_has_notary_id();
    }
    notary_id_.SetAllocatedNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited(),
        notary_id);
    // @@protoc_insertion_point(field_set_allocated:opentxs.OTDB.BitcoinServer_InternalPB.notary_id)
}

// optional string server_type = 3;
inline bool BitcoinServer_InternalPB::has_server_type() const
{
    return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void BitcoinServer_InternalPB::set_has_server_type()
{
    _has_bits_[0] |= 0x00000004u;
}
inline void BitcoinServer_InternalPB::clear_has_server_type()
{
    _has_bits_[0] &= ~0x00000004u;
}
inline void BitcoinServer_InternalPB::clear_server_type()
{
    server_type_.ClearToEmptyNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
    clear_has_server_type();
}
inline const ::std::string& BitcoinServer_InternalPB::server_type() const
{
    // @@protoc_insertion_point(field_get:opentxs.OTDB.BitcoinServer_InternalPB.server_type)
    return server_type_.GetNoArena();
}
inline void BitcoinServer_InternalPB::set_server_type(
    const ::std::string& value)
{
    set_has_server_type();
    server_type_.SetNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
    // @@protoc_insertion_point(field_set:opentxs.OTDB.BitcoinServer_InternalPB.server_type)
}
#if LANG_CXX11
inline void BitcoinServer_InternalPB::set_server_type(::std::string&& value)
{
    set_has_server_type();
    server_type_.SetNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited(),
        ::std::move(value));
    // @@protoc_insertion_point(field_set_rvalue:opentxs.OTDB.BitcoinServer_InternalPB.server_type)
}
#endif
inline void BitcoinServer_InternalPB::set_server_type(const char* value)
{
    GOOGLE_DCHECK(value != NULL);
    set_has_server_type();
    server_type_.SetNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited(),
        ::std::string(value));
    // @@protoc_insertion_point(field_set_char:opentxs.OTDB.BitcoinServer_InternalPB.server_type)
}
inline void BitcoinServer_InternalPB::set_server_type(
    const char* value,
    size_t size)
{
    set_has_server_type();
    server_type_.SetNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited(),
        ::std::string(reinterpret_cast<const char*>(value), size));
    // @@protoc_insertion_point(field_set_pointer:opentxs.OTDB.BitcoinServer_InternalPB.server_type)
}
inline ::std::string* BitcoinServer_InternalPB::mutable_server_type()
{
    set_has_server_type();
    // @@protoc_insertion_point(field_mutable:opentxs.OTDB.BitcoinServer_InternalPB.server_type)
    return server_type_.MutableNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* BitcoinServer_InternalPB::release_server_type()
{
    // @@protoc_insertion_point(field_release:opentxs.OTDB.BitcoinServer_InternalPB.server_type)
    clear_has_server_type();
    return server_type_.ReleaseNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void BitcoinServer_InternalPB::set_allocated_server_type(
    ::std::string* server_type)
{
    if (server_type != NULL) {
        set_has_server_type();
    } else {
        clear_has_server_type();
    }
    server_type_.SetAllocatedNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited(),
        server_type);
    // @@protoc_insertion_point(field_set_allocated:opentxs.OTDB.BitcoinServer_InternalPB.server_type)
}

// optional string server_host = 4;
inline bool BitcoinServer_InternalPB::has_server_host() const
{
    return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void BitcoinServer_InternalPB::set_has_server_host()
{
    _has_bits_[0] |= 0x00000008u;
}
inline void BitcoinServer_InternalPB::clear_has_server_host()
{
    _has_bits_[0] &= ~0x00000008u;
}
inline void BitcoinServer_InternalPB::clear_server_host()
{
    server_host_.ClearToEmptyNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
    clear_has_server_host();
}
inline const ::std::string& BitcoinServer_InternalPB::server_host() const
{
    // @@protoc_insertion_point(field_get:opentxs.OTDB.BitcoinServer_InternalPB.server_host)
    return server_host_.GetNoArena();
}
inline void BitcoinServer_InternalPB::set_server_host(
    const ::std::string& value)
{
    set_has_server_host();
    server_host_.SetNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
    // @@protoc_insertion_point(field_set:opentxs.OTDB.BitcoinServer_InternalPB.server_host)
}
#if LANG_CXX11
inline void BitcoinServer_InternalPB::set_server_host(::std::string&& value)
{
    set_has_server_host();
    server_host_.SetNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited(),
        ::std::move(value));
    // @@protoc_insertion_point(field_set_rvalue:opentxs.OTDB.BitcoinServer_InternalPB.server_host)
}
#endif
inline void BitcoinServer_InternalPB::set_server_host(const char* value)
{
    GOOGLE_DCHECK(value != NULL);
    set_has_server_host();
    server_host_.SetNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited(),
        ::std::string(value));
    // @@protoc_insertion_point(field_set_char:opentxs.OTDB.BitcoinServer_InternalPB.server_host)
}
inline void BitcoinServer_InternalPB::set_server_host(
    const char* value,
    size_t size)
{
    set_has_server_host();
    server_host_.SetNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited(),
        ::std::string(reinterpret_cast<const char*>(value), size));
    // @@protoc_insertion_point(field_set_pointer:opentxs.OTDB.BitcoinServer_InternalPB.server_host)
}
inline ::std::string* BitcoinServer_InternalPB::mutable_server_host()
{
    set_has_server_host();
    // @@protoc_insertion_point(field_mutable:opentxs.OTDB.BitcoinServer_InternalPB.server_host)
    return server_host_.MutableNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* BitcoinServer_InternalPB::release_server_host()
{
    // @@protoc_insertion_point(field_release:opentxs.OTDB.BitcoinServer_InternalPB.server_host)
    clear_has_server_host();
    return server_host_.ReleaseNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void BitcoinServer_InternalPB::set_allocated_server_host(
    ::std::string* server_host)
{
    if (server_host != NULL) {
        set_has_server_host();
    } else {
        clear_has_server_host();
    }
    server_host_.SetAllocatedNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited(),
        server_host);
    // @@protoc_insertion_point(field_set_allocated:opentxs.OTDB.BitcoinServer_InternalPB.server_host)
}

// optional string server_port = 5;
inline bool BitcoinServer_InternalPB::has_server_port() const
{
    return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void BitcoinServer_InternalPB::set_has_server_port()
{
    _has_bits_[0] |= 0x00000010u;
}
inline void BitcoinServer_InternalPB::clear_has_server_port()
{
    _has_bits_[0] &= ~0x00000010u;
}
inline void BitcoinServer_InternalPB::clear_server_port()
{
    server_port_.ClearToEmptyNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
    clear_has_server_port();
}
inline const ::std::string& BitcoinServer_InternalPB::server_port() const
{
    // @@protoc_insertion_point(field_get:opentxs.OTDB.BitcoinServer_InternalPB.server_port)
    return server_port_.GetNoArena();
}
inline void BitcoinServer_InternalPB::set_server_port(
    const ::std::string& value)
{
    set_has_server_port();
    server_port_.SetNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
    // @@protoc_insertion_point(field_set:opentxs.OTDB.BitcoinServer_InternalPB.server_port)
}
#if LANG_CXX11
inline void BitcoinServer_InternalPB::set_server_port(::std::string&& value)
{
    set_has_server_port();
    server_port_.SetNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited(),
        ::std::move(value));
    // @@protoc_insertion_point(field_set_rvalue:opentxs.OTDB.BitcoinServer_InternalPB.server_port)
}
#endif
inline void BitcoinServer_InternalPB::set_server_port(const char* value)
{
    GOOGLE_DCHECK(value != NULL);
    set_has_server_port();
    server_port_.SetNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited(),
        ::std::string(value));
    // @@protoc_insertion_point(field_set_char:opentxs.OTDB.BitcoinServer_InternalPB.server_port)
}
inline void BitcoinServer_InternalPB::set_server_port(
    const char* value,
    size_t size)
{
    set_has_server_port();
    server_port_.SetNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited(),
        ::std::string(reinterpret_cast<const char*>(value), size));
    // @@protoc_insertion_point(field_set_pointer:opentxs.OTDB.BitcoinServer_InternalPB.server_port)
}
inline ::std::string* BitcoinServer_InternalPB::mutable_server_port()
{
    set_has_server_port();
    // @@protoc_insertion_point(field_mutable:opentxs.OTDB.BitcoinServer_InternalPB.server_port)
    return server_port_.MutableNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* BitcoinServer_InternalPB::release_server_port()
{
    // @@protoc_insertion_point(field_release:opentxs.OTDB.BitcoinServer_InternalPB.server_port)
    clear_has_server_port();
    return server_port_.ReleaseNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void BitcoinServer_InternalPB::set_allocated_server_port(
    ::std::string* server_port)
{
    if (server_port != NULL) {
        set_has_server_port();
    } else {
        clear_has_server_port();
    }
    server_port_.SetAllocatedNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited(),
        server_port);
    // @@protoc_insertion_point(field_set_allocated:opentxs.OTDB.BitcoinServer_InternalPB.server_port)
}

// optional string bitcoin_username = 6;
inline bool BitcoinServer_InternalPB::has_bitcoin_username() const
{
    return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void BitcoinServer_InternalPB::set_has_bitcoin_username()
{
    _has_bits_[0] |= 0x00000020u;
}
inline void BitcoinServer_InternalPB::clear_has_bitcoin_username()
{
    _has_bits_[0] &= ~0x00000020u;
}
inline void BitcoinServer_InternalPB::clear_bitcoin_username()
{
    bitcoin_username_.ClearToEmptyNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
    clear_has_bitcoin_username();
}
inline const ::std::string& BitcoinServer_InternalPB::bitcoin_username() const
{
    // @@protoc_insertion_point(field_get:opentxs.OTDB.BitcoinServer_InternalPB.bitcoin_username)
    return bitcoin_username_.GetNoArena();
}
inline void BitcoinServer_InternalPB::set_bitcoin_username(
    const ::std::string& value)
{
    set_has_bitcoin_username();
    bitcoin_username_.SetNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
    // @@protoc_insertion_point(field_set:opentxs.OTDB.BitcoinServer_InternalPB.bitcoin_username)
}
#if LANG_CXX11
inline void BitcoinServer_InternalPB::set_bitcoin_username(
    ::std::string&& value)
{
    set_has_bitcoin_username();
    bitcoin_username_.SetNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited(),
        ::std::move(value));
    // @@protoc_insertion_point(field_set_rvalue:opentxs.OTDB.BitcoinServer_InternalPB.bitcoin_username)
}
#endif
inline void BitcoinServer_InternalPB::set_bitcoin_username(const char* value)
{
    GOOGLE_DCHECK(value != NULL);
    set_has_bitcoin_username();
    bitcoin_username_.SetNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited(),
        ::std::string(value));
    // @@protoc_insertion_point(field_set_char:opentxs.OTDB.BitcoinServer_InternalPB.bitcoin_username)
}
inline void BitcoinServer_InternalPB::set_bitcoin_username(
    const char* value,
    size_t size)
{
    set_has_bitcoin_username();
    bitcoin_username_.SetNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited(),
        ::std::string(reinterpret_cast<const char*>(value), size));
    // @@protoc_insertion_point(field_set_pointer:opentxs.OTDB.BitcoinServer_InternalPB.bitcoin_username)
}
inline ::std::string* BitcoinServer_InternalPB::mutable_bitcoin_username()
{
    set_has_bitcoin_username();
    // @@protoc_insertion_point(field_mutable:opentxs.OTDB.BitcoinServer_InternalPB.bitcoin_username)
    return bitcoin_username_.MutableNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* BitcoinServer_InternalPB::release_bitcoin_username()
{
    // @@protoc_insertion_point(field_release:opentxs.OTDB.BitcoinServer_InternalPB.bitcoin_username)
    clear_has_bitcoin_username();
    return bitcoin_username_.ReleaseNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void BitcoinServer_InternalPB::set_allocated_bitcoin_username(
    ::std::string* bitcoin_username)
{
    if (bitcoin_username != NULL) {
        set_has_bitcoin_username();
    } else {
        clear_has_bitcoin_username();
    }
    bitcoin_username_.SetAllocatedNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited(),
        bitcoin_username);
    // @@protoc_insertion_point(field_set_allocated:opentxs.OTDB.BitcoinServer_InternalPB.bitcoin_username)
}

// optional string bitcoin_password = 7;
inline bool BitcoinServer_InternalPB::has_bitcoin_password() const
{
    return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void BitcoinServer_InternalPB::set_has_bitcoin_password()
{
    _has_bits_[0] |= 0x00000040u;
}
inline void BitcoinServer_InternalPB::clear_has_bitcoin_password()
{
    _has_bits_[0] &= ~0x00000040u;
}
inline void BitcoinServer_InternalPB::clear_bitcoin_password()
{
    bitcoin_password_.ClearToEmptyNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
    clear_has_bitcoin_password();
}
inline const ::std::string& BitcoinServer_InternalPB::bitcoin_password() const
{
    // @@protoc_insertion_point(field_get:opentxs.OTDB.BitcoinServer_InternalPB.bitcoin_password)
    return bitcoin_password_.GetNoArena();
}
inline void BitcoinServer_InternalPB::set_bitcoin_password(
    const ::std::string& value)
{
    set_has_bitcoin_password();
    bitcoin_password_.SetNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
    // @@protoc_insertion_point(field_set:opentxs.OTDB.BitcoinServer_InternalPB.bitcoin_password)
}
#if LANG_CXX11
inline void BitcoinServer_InternalPB::set_bitcoin_password(
    ::std::string&& value)
{
    set_has_bitcoin_password();
    bitcoin_password_.SetNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited(),
        ::std::move(value));
    // @@protoc_insertion_point(field_set_rvalue:opentxs.OTDB.BitcoinServer_InternalPB.bitcoin_password)
}
#endif
inline void BitcoinServer_InternalPB::set_bitcoin_password(const char* value)
{
    GOOGLE_DCHECK(value != NULL);
    set_has_bitcoin_password();
    bitcoin_password_.SetNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited(),
        ::std::string(value));
    // @@protoc_insertion_point(field_set_char:opentxs.OTDB.BitcoinServer_InternalPB.bitcoin_password)
}
inline void BitcoinServer_InternalPB::set_bitcoin_password(
    const char* value,
    size_t size)
{
    set_has_bitcoin_password();
    bitcoin_password_.SetNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited(),
        ::std::string(reinterpret_cast<const char*>(value), size));
    // @@protoc_insertion_point(field_set_pointer:opentxs.OTDB.BitcoinServer_InternalPB.bitcoin_password)
}
inline ::std::string* BitcoinServer_InternalPB::mutable_bitcoin_password()
{
    set_has_bitcoin_password();
    // @@protoc_insertion_point(field_mutable:opentxs.OTDB.BitcoinServer_InternalPB.bitcoin_password)
    return bitcoin_password_.MutableNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* BitcoinServer_InternalPB::release_bitcoin_password()
{
    // @@protoc_insertion_point(field_release:opentxs.OTDB.BitcoinServer_InternalPB.bitcoin_password)
    clear_has_bitcoin_password();
    return bitcoin_password_.ReleaseNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void BitcoinServer_InternalPB::set_allocated_bitcoin_password(
    ::std::string* bitcoin_password)
{
    if (bitcoin_password != NULL) {
        set_has_bitcoin_password();
    } else {
        clear_has_bitcoin_password();
    }
    bitcoin_password_.SetAllocatedNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited(),
        bitcoin_password);
    // @@protoc_insertion_point(field_set_allocated:opentxs.OTDB.BitcoinServer_InternalPB.bitcoin_password)
}

// -------------------------------------------------------------------

// RippleServer_InternalPB

// optional string gui_label = 1;
inline bool RippleServer_InternalPB::has_gui_label() const
{
    return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RippleServer_InternalPB::set_has_gui_label()
{
    _has_bits_[0] |= 0x00000001u;
}
inline void RippleServer_InternalPB::clear_has_gui_label()
{
    _has_bits_[0] &= ~0x00000001u;
}
inline void RippleServer_InternalPB::clear_gui_label()
{
    gui_label_.ClearToEmptyNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
    clear_has_gui_label();
}
inline const ::std::string& RippleServer_InternalPB::gui_label() const
{
    // @@protoc_insertion_point(field_get:opentxs.OTDB.RippleServer_InternalPB.gui_label)
    return gui_label_.GetNoArena();
}
inline void RippleServer_InternalPB::set_gui_label(const ::std::string& value)
{
    set_has_gui_label();
    gui_label_.SetNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
    // @@protoc_insertion_point(field_set:opentxs.OTDB.RippleServer_InternalPB.gui_label)
}
#if LANG_CXX11
inline void RippleServer_InternalPB::set_gui_label(::std::string&& value)
{
    set_has_gui_label();
    gui_label_.SetNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited(),
        ::std::move(value));
    // @@protoc_insertion_point(field_set_rvalue:opentxs.OTDB.RippleServer_InternalPB.gui_label)
}
#endif
inline void RippleServer_InternalPB::set_gui_label(const char* value)
{
    GOOGLE_DCHECK(value != NULL);
    set_has_gui_label();
    gui_label_.SetNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited(),
        ::std::string(value));
    // @@protoc_insertion_point(field_set_char:opentxs.OTDB.RippleServer_InternalPB.gui_label)
}
inline void RippleServer_InternalPB::set_gui_label(
    const char* value,
    size_t size)
{
    set_has_gui_label();
    gui_label_.SetNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited(),
        ::std::string(reinterpret_cast<const char*>(value), size));
    // @@protoc_insertion_point(field_set_pointer:opentxs.OTDB.RippleServer_InternalPB.gui_label)
}
inline ::std::string* RippleServer_InternalPB::mutable_gui_label()
{
    set_has_gui_label();
    // @@protoc_insertion_point(field_mutable:opentxs.OTDB.RippleServer_InternalPB.gui_label)
    return gui_label_.MutableNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* RippleServer_InternalPB::release_gui_label()
{
    // @@protoc_insertion_point(field_release:opentxs.OTDB.RippleServer_InternalPB.gui_label)
    clear_has_gui_label();
    return gui_label_.ReleaseNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void RippleServer_InternalPB::set_allocated_gui_label(
    ::std::string* gui_label)
{
    if (gui_label != NULL) {
        set_has_gui_label();
    } else {
        clear_has_gui_label();
    }
    gui_label_.SetAllocatedNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited(),
        gui_label);
    // @@protoc_insertion_point(field_set_allocated:opentxs.OTDB.RippleServer_InternalPB.gui_label)
}

// optional string notary_id = 2;
inline bool RippleServer_InternalPB::has_notary_id() const
{
    return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RippleServer_InternalPB::set_has_notary_id()
{
    _has_bits_[0] |= 0x00000002u;
}
inline void RippleServer_InternalPB::clear_has_notary_id()
{
    _has_bits_[0] &= ~0x00000002u;
}
inline void RippleServer_InternalPB::clear_notary_id()
{
    notary_id_.ClearToEmptyNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
    clear_has_notary_id();
}
inline const ::std::string& RippleServer_InternalPB::notary_id() const
{
    // @@protoc_insertion_point(field_get:opentxs.OTDB.RippleServer_InternalPB.notary_id)
    return notary_id_.GetNoArena();
}
inline void RippleServer_InternalPB::set_notary_id(const ::std::string& value)
{
    set_has_notary_id();
    notary_id_.SetNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
    // @@protoc_insertion_point(field_set:opentxs.OTDB.RippleServer_InternalPB.notary_id)
}
#if LANG_CXX11
inline void RippleServer_InternalPB::set_notary_id(::std::string&& value)
{
    set_has_notary_id();
    notary_id_.SetNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited(),
        ::std::move(value));
    // @@protoc_insertion_point(field_set_rvalue:opentxs.OTDB.RippleServer_InternalPB.notary_id)
}
#endif
inline void RippleServer_InternalPB::set_notary_id(const char* value)
{
    GOOGLE_DCHECK(value != NULL);
    set_has_notary_id();
    notary_id_.SetNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited(),
        ::std::string(value));
    // @@protoc_insertion_point(field_set_char:opentxs.OTDB.RippleServer_InternalPB.notary_id)
}
inline void RippleServer_InternalPB::set_notary_id(
    const char* value,
    size_t size)
{
    set_has_notary_id();
    notary_id_.SetNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited(),
        ::std::string(reinterpret_cast<const char*>(value), size));
    // @@protoc_insertion_point(field_set_pointer:opentxs.OTDB.RippleServer_InternalPB.notary_id)
}
inline ::std::string* RippleServer_InternalPB::mutable_notary_id()
{
    set_has_notary_id();
    // @@protoc_insertion_point(field_mutable:opentxs.OTDB.RippleServer_InternalPB.notary_id)
    return notary_id_.MutableNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* RippleServer_InternalPB::release_notary_id()
{
    // @@protoc_insertion_point(field_release:opentxs.OTDB.RippleServer_InternalPB.notary_id)
    clear_has_notary_id();
    return notary_id_.ReleaseNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void RippleServer_InternalPB::set_allocated_notary_id(
    ::std::string* notary_id)
{
    if (notary_id != NULL) {
        set_has_notary_id();
    } else {
        clear_has_notary_id();
    }
    notary_id_.SetAllocatedNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited(),
        notary_id);
    // @@protoc_insertion_point(field_set_allocated:opentxs.OTDB.RippleServer_InternalPB.notary_id)
}

// optional string server_type = 3;
inline bool RippleServer_InternalPB::has_server_type() const
{
    return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void RippleServer_InternalPB::set_has_server_type()
{
    _has_bits_[0] |= 0x00000004u;
}
inline void RippleServer_InternalPB::clear_has_server_type()
{
    _has_bits_[0] &= ~0x00000004u;
}
inline void RippleServer_InternalPB::clear_server_type()
{
    server_type_.ClearToEmptyNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
    clear_has_server_type();
}
inline const ::std::string& RippleServer_InternalPB::server_type() const
{
    // @@protoc_insertion_point(field_get:opentxs.OTDB.RippleServer_InternalPB.server_type)
    return server_type_.GetNoArena();
}
inline void RippleServer_InternalPB::set_server_type(const ::std::string& value)
{
    set_has_server_type();
    server_type_.SetNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
    // @@protoc_insertion_point(field_set:opentxs.OTDB.RippleServer_InternalPB.server_type)
}
#if LANG_CXX11
inline void RippleServer_InternalPB::set_server_type(::std::string&& value)
{
    set_has_server_type();
    server_type_.SetNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited(),
        ::std::move(value));
    // @@protoc_insertion_point(field_set_rvalue:opentxs.OTDB.RippleServer_InternalPB.server_type)
}
#endif
inline void RippleServer_InternalPB::set_server_type(const char* value)
{
    GOOGLE_DCHECK(value != NULL);
    set_has_server_type();
    server_type_.SetNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited(),
        ::std::string(value));
    // @@protoc_insertion_point(field_set_char:opentxs.OTDB.RippleServer_InternalPB.server_type)
}
inline void RippleServer_InternalPB::set_server_type(
    const char* value,
    size_t size)
{
    set_has_server_type();
    server_type_.SetNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited(),
        ::std::string(reinterpret_cast<const char*>(value), size));
    // @@protoc_insertion_point(field_set_pointer:opentxs.OTDB.RippleServer_InternalPB.server_type)
}
inline ::std::string* RippleServer_InternalPB::mutable_server_type()
{
    set_has_server_type();
    // @@protoc_insertion_point(field_mutable:opentxs.OTDB.RippleServer_InternalPB.server_type)
    return server_type_.MutableNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* RippleServer_InternalPB::release_server_type()
{
    // @@protoc_insertion_point(field_release:opentxs.OTDB.RippleServer_InternalPB.server_type)
    clear_has_server_type();
    return server_type_.ReleaseNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void RippleServer_InternalPB::set_allocated_server_type(
    ::std::string* server_type)
{
    if (server_type != NULL) {
        set_has_server_type();
    } else {
        clear_has_server_type();
    }
    server_type_.SetAllocatedNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited(),
        server_type);
    // @@protoc_insertion_point(field_set_allocated:opentxs.OTDB.RippleServer_InternalPB.server_type)
}

// optional string server_host = 4;
inline bool RippleServer_InternalPB::has_server_host() const
{
    return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void RippleServer_InternalPB::set_has_server_host()
{
    _has_bits_[0] |= 0x00000008u;
}
inline void RippleServer_InternalPB::clear_has_server_host()
{
    _has_bits_[0] &= ~0x00000008u;
}
inline void RippleServer_InternalPB::clear_server_host()
{
    server_host_.ClearToEmptyNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
    clear_has_server_host();
}
inline const ::std::string& RippleServer_InternalPB::server_host() const
{
    // @@protoc_insertion_point(field_get:opentxs.OTDB.RippleServer_InternalPB.server_host)
    return server_host_.GetNoArena();
}
inline void RippleServer_InternalPB::set_server_host(const ::std::string& value)
{
    set_has_server_host();
    server_host_.SetNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
    // @@protoc_insertion_point(field_set:opentxs.OTDB.RippleServer_InternalPB.server_host)
}
#if LANG_CXX11
inline void RippleServer_InternalPB::set_server_host(::std::string&& value)
{
    set_has_server_host();
    server_host_.SetNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited(),
        ::std::move(value));
    // @@protoc_insertion_point(field_set_rvalue:opentxs.OTDB.RippleServer_InternalPB.server_host)
}
#endif
inline void RippleServer_InternalPB::set_server_host(const char* value)
{
    GOOGLE_DCHECK(value != NULL);
    set_has_server_host();
    server_host_.SetNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited(),
        ::std::string(value));
    // @@protoc_insertion_point(field_set_char:opentxs.OTDB.RippleServer_InternalPB.server_host)
}
inline void RippleServer_InternalPB::set_server_host(
    const char* value,
    size_t size)
{
    set_has_server_host();
    server_host_.SetNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited(),
        ::std::string(reinterpret_cast<const char*>(value), size));
    // @@protoc_insertion_point(field_set_pointer:opentxs.OTDB.RippleServer_InternalPB.server_host)
}
inline ::std::string* RippleServer_InternalPB::mutable_server_host()
{
    set_has_server_host();
    // @@protoc_insertion_point(field_mutable:opentxs.OTDB.RippleServer_InternalPB.server_host)
    return server_host_.MutableNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* RippleServer_InternalPB::release_server_host()
{
    // @@protoc_insertion_point(field_release:opentxs.OTDB.RippleServer_InternalPB.server_host)
    clear_has_server_host();
    return server_host_.ReleaseNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void RippleServer_InternalPB::set_allocated_server_host(
    ::std::string* server_host)
{
    if (server_host != NULL) {
        set_has_server_host();
    } else {
        clear_has_server_host();
    }
    server_host_.SetAllocatedNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited(),
        server_host);
    // @@protoc_insertion_point(field_set_allocated:opentxs.OTDB.RippleServer_InternalPB.server_host)
}

// optional string server_port = 5;
inline bool RippleServer_InternalPB::has_server_port() const
{
    return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void RippleServer_InternalPB::set_has_server_port()
{
    _has_bits_[0] |= 0x00000010u;
}
inline void RippleServer_InternalPB::clear_has_server_port()
{
    _has_bits_[0] &= ~0x00000010u;
}
inline void RippleServer_InternalPB::clear_server_port()
{
    server_port_.ClearToEmptyNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
    clear_has_server_port();
}
inline const ::std::string& RippleServer_InternalPB::server_port() const
{
    // @@protoc_insertion_point(field_get:opentxs.OTDB.RippleServer_InternalPB.server_port)
    return server_port_.GetNoArena();
}
inline void RippleServer_InternalPB::set_server_port(const ::std::string& value)
{
    set_has_server_port();
    server_port_.SetNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
    // @@protoc_insertion_point(field_set:opentxs.OTDB.RippleServer_InternalPB.server_port)
}
#if LANG_CXX11
inline void RippleServer_InternalPB::set_server_port(::std::string&& value)
{
    set_has_server_port();
    server_port_.SetNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited(),
        ::std::move(value));
    // @@protoc_insertion_point(field_set_rvalue:opentxs.OTDB.RippleServer_InternalPB.server_port)
}
#endif
inline void RippleServer_InternalPB::set_server_port(const char* value)
{
    GOOGLE_DCHECK(value != NULL);
    set_has_server_port();
    server_port_.SetNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited(),
        ::std::string(value));
    // @@protoc_insertion_point(field_set_char:opentxs.OTDB.RippleServer_InternalPB.server_port)
}
inline void RippleServer_InternalPB::set_server_port(
    const char* value,
    size_t size)
{
    set_has_server_port();
    server_port_.SetNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited(),
        ::std::string(reinterpret_cast<const char*>(value), size));
    // @@protoc_insertion_point(field_set_pointer:opentxs.OTDB.RippleServer_InternalPB.server_port)
}
inline ::std::string* RippleServer_InternalPB::mutable_server_port()
{
    set_has_server_port();
    // @@protoc_insertion_point(field_mutable:opentxs.OTDB.RippleServer_InternalPB.server_port)
    return server_port_.MutableNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* RippleServer_InternalPB::release_server_port()
{
    // @@protoc_insertion_point(field_release:opentxs.OTDB.RippleServer_InternalPB.server_port)
    clear_has_server_port();
    return server_port_.ReleaseNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void RippleServer_InternalPB::set_allocated_server_port(
    ::std::string* server_port)
{
    if (server_port != NULL) {
        set_has_server_port();
    } else {
        clear_has_server_port();
    }
    server_port_.SetAllocatedNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited(),
        server_port);
    // @@protoc_insertion_point(field_set_allocated:opentxs.OTDB.RippleServer_InternalPB.server_port)
}

// optional string ripple_username = 6;
inline bool RippleServer_InternalPB::has_ripple_username() const
{
    return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void RippleServer_InternalPB::set_has_ripple_username()
{
    _has_bits_[0] |= 0x00000020u;
}
inline void RippleServer_InternalPB::clear_has_ripple_username()
{
    _has_bits_[0] &= ~0x00000020u;
}
inline void RippleServer_InternalPB::clear_ripple_username()
{
    ripple_username_.ClearToEmptyNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
    clear_has_ripple_username();
}
inline const ::std::string& RippleServer_InternalPB::ripple_username() const
{
    // @@protoc_insertion_point(field_get:opentxs.OTDB.RippleServer_InternalPB.ripple_username)
    return ripple_username_.GetNoArena();
}
inline void RippleServer_InternalPB::set_ripple_username(
    const ::std::string& value)
{
    set_has_ripple_username();
    ripple_username_.SetNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
    // @@protoc_insertion_point(field_set:opentxs.OTDB.RippleServer_InternalPB.ripple_username)
}
#if LANG_CXX11
inline void RippleServer_InternalPB::set_ripple_username(::std::string&& value)
{
    set_has_ripple_username();
    ripple_username_.SetNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited(),
        ::std::move(value));
    // @@protoc_insertion_point(field_set_rvalue:opentxs.OTDB.RippleServer_InternalPB.ripple_username)
}
#endif
inline void RippleServer_InternalPB::set_ripple_username(const char* value)
{
    GOOGLE_DCHECK(value != NULL);
    set_has_ripple_username();
    ripple_username_.SetNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited(),
        ::std::string(value));
    // @@protoc_insertion_point(field_set_char:opentxs.OTDB.RippleServer_InternalPB.ripple_username)
}
inline void RippleServer_InternalPB::set_ripple_username(
    const char* value,
    size_t size)
{
    set_has_ripple_username();
    ripple_username_.SetNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited(),
        ::std::string(reinterpret_cast<const char*>(value), size));
    // @@protoc_insertion_point(field_set_pointer:opentxs.OTDB.RippleServer_InternalPB.ripple_username)
}
inline ::std::string* RippleServer_InternalPB::mutable_ripple_username()
{
    set_has_ripple_username();
    // @@protoc_insertion_point(field_mutable:opentxs.OTDB.RippleServer_InternalPB.ripple_username)
    return ripple_username_.MutableNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* RippleServer_InternalPB::release_ripple_username()
{
    // @@protoc_insertion_point(field_release:opentxs.OTDB.RippleServer_InternalPB.ripple_username)
    clear_has_ripple_username();
    return ripple_username_.ReleaseNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void RippleServer_InternalPB::set_allocated_ripple_username(
    ::std::string* ripple_username)
{
    if (ripple_username != NULL) {
        set_has_ripple_username();
    } else {
        clear_has_ripple_username();
    }
    ripple_username_.SetAllocatedNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited(),
        ripple_username);
    // @@protoc_insertion_point(field_set_allocated:opentxs.OTDB.RippleServer_InternalPB.ripple_username)
}

// optional string ripple_password = 7;
inline bool RippleServer_InternalPB::has_ripple_password() const
{
    return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void RippleServer_InternalPB::set_has_ripple_password()
{
    _has_bits_[0] |= 0x00000040u;
}
inline void RippleServer_InternalPB::clear_has_ripple_password()
{
    _has_bits_[0] &= ~0x00000040u;
}
inline void RippleServer_InternalPB::clear_ripple_password()
{
    ripple_password_.ClearToEmptyNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
    clear_has_ripple_password();
}
inline const ::std::string& RippleServer_InternalPB::ripple_password() const
{
    // @@protoc_insertion_point(field_get:opentxs.OTDB.RippleServer_InternalPB.ripple_password)
    return ripple_password_.GetNoArena();
}
inline void RippleServer_InternalPB::set_ripple_password(
    const ::std::string& value)
{
    set_has_ripple_password();
    ripple_password_.SetNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
    // @@protoc_insertion_point(field_set:opentxs.OTDB.RippleServer_InternalPB.ripple_password)
}
#if LANG_CXX11
inline void RippleServer_InternalPB::set_ripple_password(::std::string&& value)
{
    set_has_ripple_password();
    ripple_password_.SetNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited(),
        ::std::move(value));
    // @@protoc_insertion_point(field_set_rvalue:opentxs.OTDB.RippleServer_InternalPB.ripple_password)
}
#endif
inline void RippleServer_InternalPB::set_ripple_password(const char* value)
{
    GOOGLE_DCHECK(value != NULL);
    set_has_ripple_password();
    ripple_password_.SetNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited(),
        ::std::string(value));
    // @@protoc_insertion_point(field_set_char:opentxs.OTDB.RippleServer_InternalPB.ripple_password)
}
inline void RippleServer_InternalPB::set_ripple_password(
    const char* value,
    size_t size)
{
    set_has_ripple_password();
    ripple_password_.SetNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited(),
        ::std::string(reinterpret_cast<const char*>(value), size));
    // @@protoc_insertion_point(field_set_pointer:opentxs.OTDB.RippleServer_InternalPB.ripple_password)
}
inline ::std::string* RippleServer_InternalPB::mutable_ripple_password()
{
    set_has_ripple_password();
    // @@protoc_insertion_point(field_mutable:opentxs.OTDB.RippleServer_InternalPB.ripple_password)
    return ripple_password_.MutableNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* RippleServer_InternalPB::release_ripple_password()
{
    // @@protoc_insertion_point(field_release:opentxs.OTDB.RippleServer_InternalPB.ripple_password)
    clear_has_ripple_password();
    return ripple_password_.ReleaseNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void RippleServer_InternalPB::set_allocated_ripple_password(
    ::std::string* ripple_password)
{
    if (ripple_password != NULL) {
        set_has_ripple_password();
    } else {
        clear_has_ripple_password();
    }
    ripple_password_.SetAllocatedNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited(),
        ripple_password);
    // @@protoc_insertion_point(field_set_allocated:opentxs.OTDB.RippleServer_InternalPB.ripple_password)
}

// optional string namefield_id = 8;
inline bool RippleServer_InternalPB::has_namefield_id() const
{
    return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void RippleServer_InternalPB::set_has_namefield_id()
{
    _has_bits_[0] |= 0x00000080u;
}
inline void RippleServer_InternalPB::clear_has_namefield_id()
{
    _has_bits_[0] &= ~0x00000080u;
}
inline void RippleServer_InternalPB::clear_namefield_id()
{
    namefield_id_.ClearToEmptyNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
    clear_has_namefield_id();
}
inline const ::std::string& RippleServer_InternalPB::namefield_id() const
{
    // @@protoc_insertion_point(field_get:opentxs.OTDB.RippleServer_InternalPB.namefield_id)
    return namefield_id_.GetNoArena();
}
inline void RippleServer_InternalPB::set_namefield_id(
    const ::std::string& value)
{
    set_has_namefield_id();
    namefield_id_.SetNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
    // @@protoc_insertion_point(field_set:opentxs.OTDB.RippleServer_InternalPB.namefield_id)
}
#if LANG_CXX11
inline void RippleServer_InternalPB::set_namefield_id(::std::string&& value)
{
    set_has_namefield_id();
    namefield_id_.SetNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited(),
        ::std::move(value));
    // @@protoc_insertion_point(field_set_rvalue:opentxs.OTDB.RippleServer_InternalPB.namefield_id)
}
#endif
inline void RippleServer_InternalPB::set_namefield_id(const char* value)
{
    GOOGLE_DCHECK(value != NULL);
    set_has_namefield_id();
    namefield_id_.SetNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited(),
        ::std::string(value));
    // @@protoc_insertion_point(field_set_char:opentxs.OTDB.RippleServer_InternalPB.namefield_id)
}
inline void RippleServer_InternalPB::set_namefield_id(
    const char* value,
    size_t size)
{
    set_has_namefield_id();
    namefield_id_.SetNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited(),
        ::std::string(reinterpret_cast<const char*>(value), size));
    // @@protoc_insertion_point(field_set_pointer:opentxs.OTDB.RippleServer_InternalPB.namefield_id)
}
inline ::std::string* RippleServer_InternalPB::mutable_namefield_id()
{
    set_has_namefield_id();
    // @@protoc_insertion_point(field_mutable:opentxs.OTDB.RippleServer_InternalPB.namefield_id)
    return namefield_id_.MutableNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* RippleServer_InternalPB::release_namefield_id()
{
    // @@protoc_insertion_point(field_release:opentxs.OTDB.RippleServer_InternalPB.namefield_id)
    clear_has_namefield_id();
    return namefield_id_.ReleaseNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void RippleServer_InternalPB::set_allocated_namefield_id(
    ::std::string* namefield_id)
{
    if (namefield_id != NULL) {
        set_has_namefield_id();
    } else {
        clear_has_namefield_id();
    }
    namefield_id_.SetAllocatedNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited(),
        namefield_id);
    // @@protoc_insertion_point(field_set_allocated:opentxs.OTDB.RippleServer_InternalPB.namefield_id)
}

// optional string passfield_id = 9;
inline bool RippleServer_InternalPB::has_passfield_id() const
{
    return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void RippleServer_InternalPB::set_has_passfield_id()
{
    _has_bits_[0] |= 0x00000100u;
}
inline void RippleServer_InternalPB::clear_has_passfield_id()
{
    _has_bits_[0] &= ~0x00000100u;
}
inline void RippleServer_InternalPB::clear_passfield_id()
{
    passfield_id_.ClearToEmptyNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
    clear_has_passfield_id();
}
inline const ::std::string& RippleServer_InternalPB::passfield_id() const
{
    // @@protoc_insertion_point(field_get:opentxs.OTDB.RippleServer_InternalPB.passfield_id)
    return passfield_id_.GetNoArena();
}
inline void RippleServer_InternalPB::set_passfield_id(
    const ::std::string& value)
{
    set_has_passfield_id();
    passfield_id_.SetNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
    // @@protoc_insertion_point(field_set:opentxs.OTDB.RippleServer_InternalPB.passfield_id)
}
#if LANG_CXX11
inline void RippleServer_InternalPB::set_passfield_id(::std::string&& value)
{
    set_has_passfield_id();
    passfield_id_.SetNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited(),
        ::std::move(value));
    // @@protoc_insertion_point(field_set_rvalue:opentxs.OTDB.RippleServer_InternalPB.passfield_id)
}
#endif
inline void RippleServer_InternalPB::set_passfield_id(const char* value)
{
    GOOGLE_DCHECK(value != NULL);
    set_has_passfield_id();
    passfield_id_.SetNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited(),
        ::std::string(value));
    // @@protoc_insertion_point(field_set_char:opentxs.OTDB.RippleServer_InternalPB.passfield_id)
}
inline void RippleServer_InternalPB::set_passfield_id(
    const char* value,
    size_t size)
{
    set_has_passfield_id();
    passfield_id_.SetNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited(),
        ::std::string(reinterpret_cast<const char*>(value), size));
    // @@protoc_insertion_point(field_set_pointer:opentxs.OTDB.RippleServer_InternalPB.passfield_id)
}
inline ::std::string* RippleServer_InternalPB::mutable_passfield_id()
{
    set_has_passfield_id();
    // @@protoc_insertion_point(field_mutable:opentxs.OTDB.RippleServer_InternalPB.passfield_id)
    return passfield_id_.MutableNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* RippleServer_InternalPB::release_passfield_id()
{
    // @@protoc_insertion_point(field_release:opentxs.OTDB.RippleServer_InternalPB.passfield_id)
    clear_has_passfield_id();
    return passfield_id_.ReleaseNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void RippleServer_InternalPB::set_allocated_passfield_id(
    ::std::string* passfield_id)
{
    if (passfield_id != NULL) {
        set_has_passfield_id();
    } else {
        clear_has_passfield_id();
    }
    passfield_id_.SetAllocatedNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited(),
        passfield_id);
    // @@protoc_insertion_point(field_set_allocated:opentxs.OTDB.RippleServer_InternalPB.passfield_id)
}

// -------------------------------------------------------------------

// LoomServer_InternalPB

// optional string gui_label = 1;
inline bool LoomServer_InternalPB::has_gui_label() const
{
    return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void LoomServer_InternalPB::set_has_gui_label()
{
    _has_bits_[0] |= 0x00000001u;
}
inline void LoomServer_InternalPB::clear_has_gui_label()
{
    _has_bits_[0] &= ~0x00000001u;
}
inline void LoomServer_InternalPB::clear_gui_label()
{
    gui_label_.ClearToEmptyNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
    clear_has_gui_label();
}
inline const ::std::string& LoomServer_InternalPB::gui_label() const
{
    // @@protoc_insertion_point(field_get:opentxs.OTDB.LoomServer_InternalPB.gui_label)
    return gui_label_.GetNoArena();
}
inline void LoomServer_InternalPB::set_gui_label(const ::std::string& value)
{
    set_has_gui_label();
    gui_label_.SetNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
    // @@protoc_insertion_point(field_set:opentxs.OTDB.LoomServer_InternalPB.gui_label)
}
#if LANG_CXX11
inline void LoomServer_InternalPB::set_gui_label(::std::string&& value)
{
    set_has_gui_label();
    gui_label_.SetNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited(),
        ::std::move(value));
    // @@protoc_insertion_point(field_set_rvalue:opentxs.OTDB.LoomServer_InternalPB.gui_label)
}
#endif
inline void LoomServer_InternalPB::set_gui_label(const char* value)
{
    GOOGLE_DCHECK(value != NULL);
    set_has_gui_label();
    gui_label_.SetNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited(),
        ::std::string(value));
    // @@protoc_insertion_point(field_set_char:opentxs.OTDB.LoomServer_InternalPB.gui_label)
}
inline void LoomServer_InternalPB::set_gui_label(const char* value, size_t size)
{
    set_has_gui_label();
    gui_label_.SetNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited(),
        ::std::string(reinterpret_cast<const char*>(value), size));
    // @@protoc_insertion_point(field_set_pointer:opentxs.OTDB.LoomServer_InternalPB.gui_label)
}
inline ::std::string* LoomServer_InternalPB::mutable_gui_label()
{
    set_has_gui_label();
    // @@protoc_insertion_point(field_mutable:opentxs.OTDB.LoomServer_InternalPB.gui_label)
    return gui_label_.MutableNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* LoomServer_InternalPB::release_gui_label()
{
    // @@protoc_insertion_point(field_release:opentxs.OTDB.LoomServer_InternalPB.gui_label)
    clear_has_gui_label();
    return gui_label_.ReleaseNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void LoomServer_InternalPB::set_allocated_gui_label(
    ::std::string* gui_label)
{
    if (gui_label != NULL) {
        set_has_gui_label();
    } else {
        clear_has_gui_label();
    }
    gui_label_.SetAllocatedNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited(),
        gui_label);
    // @@protoc_insertion_point(field_set_allocated:opentxs.OTDB.LoomServer_InternalPB.gui_label)
}

// optional string notary_id = 2;
inline bool LoomServer_InternalPB::has_notary_id() const
{
    return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void LoomServer_InternalPB::set_has_notary_id()
{
    _has_bits_[0] |= 0x00000002u;
}
inline void LoomServer_InternalPB::clear_has_notary_id()
{
    _has_bits_[0] &= ~0x00000002u;
}
inline void LoomServer_InternalPB::clear_notary_id()
{
    notary_id_.ClearToEmptyNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
    clear_has_notary_id();
}
inline const ::std::string& LoomServer_InternalPB::notary_id() const
{
    // @@protoc_insertion_point(field_get:opentxs.OTDB.LoomServer_InternalPB.notary_id)
    return notary_id_.GetNoArena();
}
inline void LoomServer_InternalPB::set_notary_id(const ::std::string& value)
{
    set_has_notary_id();
    notary_id_.SetNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
    // @@protoc_insertion_point(field_set:opentxs.OTDB.LoomServer_InternalPB.notary_id)
}
#if LANG_CXX11
inline void LoomServer_InternalPB::set_notary_id(::std::string&& value)
{
    set_has_notary_id();
    notary_id_.SetNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited(),
        ::std::move(value));
    // @@protoc_insertion_point(field_set_rvalue:opentxs.OTDB.LoomServer_InternalPB.notary_id)
}
#endif
inline void LoomServer_InternalPB::set_notary_id(const char* value)
{
    GOOGLE_DCHECK(value != NULL);
    set_has_notary_id();
    notary_id_.SetNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited(),
        ::std::string(value));
    // @@protoc_insertion_point(field_set_char:opentxs.OTDB.LoomServer_InternalPB.notary_id)
}
inline void LoomServer_InternalPB::set_notary_id(const char* value, size_t size)
{
    set_has_notary_id();
    notary_id_.SetNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited(),
        ::std::string(reinterpret_cast<const char*>(value), size));
    // @@protoc_insertion_point(field_set_pointer:opentxs.OTDB.LoomServer_InternalPB.notary_id)
}
inline ::std::string* LoomServer_InternalPB::mutable_notary_id()
{
    set_has_notary_id();
    // @@protoc_insertion_point(field_mutable:opentxs.OTDB.LoomServer_InternalPB.notary_id)
    return notary_id_.MutableNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* LoomServer_InternalPB::release_notary_id()
{
    // @@protoc_insertion_point(field_release:opentxs.OTDB.LoomServer_InternalPB.notary_id)
    clear_has_notary_id();
    return notary_id_.ReleaseNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void LoomServer_InternalPB::set_allocated_notary_id(
    ::std::string* notary_id)
{
    if (notary_id != NULL) {
        set_has_notary_id();
    } else {
        clear_has_notary_id();
    }
    notary_id_.SetAllocatedNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited(),
        notary_id);
    // @@protoc_insertion_point(field_set_allocated:opentxs.OTDB.LoomServer_InternalPB.notary_id)
}

// optional string server_type = 3;
inline bool LoomServer_InternalPB::has_server_type() const
{
    return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void LoomServer_InternalPB::set_has_server_type()
{
    _has_bits_[0] |= 0x00000004u;
}
inline void LoomServer_InternalPB::clear_has_server_type()
{
    _has_bits_[0] &= ~0x00000004u;
}
inline void LoomServer_InternalPB::clear_server_type()
{
    server_type_.ClearToEmptyNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
    clear_has_server_type();
}
inline const ::std::string& LoomServer_InternalPB::server_type() const
{
    // @@protoc_insertion_point(field_get:opentxs.OTDB.LoomServer_InternalPB.server_type)
    return server_type_.GetNoArena();
}
inline void LoomServer_InternalPB::set_server_type(const ::std::string& value)
{
    set_has_server_type();
    server_type_.SetNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
    // @@protoc_insertion_point(field_set:opentxs.OTDB.LoomServer_InternalPB.server_type)
}
#if LANG_CXX11
inline void LoomServer_InternalPB::set_server_type(::std::string&& value)
{
    set_has_server_type();
    server_type_.SetNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited(),
        ::std::move(value));
    // @@protoc_insertion_point(field_set_rvalue:opentxs.OTDB.LoomServer_InternalPB.server_type)
}
#endif
inline void LoomServer_InternalPB::set_server_type(const char* value)
{
    GOOGLE_DCHECK(value != NULL);
    set_has_server_type();
    server_type_.SetNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited(),
        ::std::string(value));
    // @@protoc_insertion_point(field_set_char:opentxs.OTDB.LoomServer_InternalPB.server_type)
}
inline void LoomServer_InternalPB::set_server_type(
    const char* value,
    size_t size)
{
    set_has_server_type();
    server_type_.SetNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited(),
        ::std::string(reinterpret_cast<const char*>(value), size));
    // @@protoc_insertion_point(field_set_pointer:opentxs.OTDB.LoomServer_InternalPB.server_type)
}
inline ::std::string* LoomServer_InternalPB::mutable_server_type()
{
    set_has_server_type();
    // @@protoc_insertion_point(field_mutable:opentxs.OTDB.LoomServer_InternalPB.server_type)
    return server_type_.MutableNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* LoomServer_InternalPB::release_server_type()
{
    // @@protoc_insertion_point(field_release:opentxs.OTDB.LoomServer_InternalPB.server_type)
    clear_has_server_type();
    return server_type_.ReleaseNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void LoomServer_InternalPB::set_allocated_server_type(
    ::std::string* server_type)
{
    if (server_type != NULL) {
        set_has_server_type();
    } else {
        clear_has_server_type();
    }
    server_type_.SetAllocatedNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited(),
        server_type);
    // @@protoc_insertion_point(field_set_allocated:opentxs.OTDB.LoomServer_InternalPB.server_type)
}

// optional string server_host = 4;
inline bool LoomServer_InternalPB::has_server_host() const
{
    return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void LoomServer_InternalPB::set_has_server_host()
{
    _has_bits_[0] |= 0x00000008u;
}
inline void LoomServer_InternalPB::clear_has_server_host()
{
    _has_bits_[0] &= ~0x00000008u;
}
inline void LoomServer_InternalPB::clear_server_host()
{
    server_host_.ClearToEmptyNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
    clear_has_server_host();
}
inline const ::std::string& LoomServer_InternalPB::server_host() const
{
    // @@protoc_insertion_point(field_get:opentxs.OTDB.LoomServer_InternalPB.server_host)
    return server_host_.GetNoArena();
}
inline void LoomServer_InternalPB::set_server_host(const ::std::string& value)
{
    set_has_server_host();
    server_host_.SetNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
    // @@protoc_insertion_point(field_set:opentxs.OTDB.LoomServer_InternalPB.server_host)
}
#if LANG_CXX11
inline void LoomServer_InternalPB::set_server_host(::std::string&& value)
{
    set_has_server_host();
    server_host_.SetNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited(),
        ::std::move(value));
    // @@protoc_insertion_point(field_set_rvalue:opentxs.OTDB.LoomServer_InternalPB.server_host)
}
#endif
inline void LoomServer_InternalPB::set_server_host(const char* value)
{
    GOOGLE_DCHECK(value != NULL);
    set_has_server_host();
    server_host_.SetNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited(),
        ::std::string(value));
    // @@protoc_insertion_point(field_set_char:opentxs.OTDB.LoomServer_InternalPB.server_host)
}
inline void LoomServer_InternalPB::set_server_host(
    const char* value,
    size_t size)
{
    set_has_server_host();
    server_host_.SetNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited(),
        ::std::string(reinterpret_cast<const char*>(value), size));
    // @@protoc_insertion_point(field_set_pointer:opentxs.OTDB.LoomServer_InternalPB.server_host)
}
inline ::std::string* LoomServer_InternalPB::mutable_server_host()
{
    set_has_server_host();
    // @@protoc_insertion_point(field_mutable:opentxs.OTDB.LoomServer_InternalPB.server_host)
    return server_host_.MutableNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* LoomServer_InternalPB::release_server_host()
{
    // @@protoc_insertion_point(field_release:opentxs.OTDB.LoomServer_InternalPB.server_host)
    clear_has_server_host();
    return server_host_.ReleaseNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void LoomServer_InternalPB::set_allocated_server_host(
    ::std::string* server_host)
{
    if (server_host != NULL) {
        set_has_server_host();
    } else {
        clear_has_server_host();
    }
    server_host_.SetAllocatedNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited(),
        server_host);
    // @@protoc_insertion_point(field_set_allocated:opentxs.OTDB.LoomServer_InternalPB.server_host)
}

// optional string server_port = 5;
inline bool LoomServer_InternalPB::has_server_port() const
{
    return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void LoomServer_InternalPB::set_has_server_port()
{
    _has_bits_[0] |= 0x00000010u;
}
inline void LoomServer_InternalPB::clear_has_server_port()
{
    _has_bits_[0] &= ~0x00000010u;
}
inline void LoomServer_InternalPB::clear_server_port()
{
    server_port_.ClearToEmptyNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
    clear_has_server_port();
}
inline const ::std::string& LoomServer_InternalPB::server_port() const
{
    // @@protoc_insertion_point(field_get:opentxs.OTDB.LoomServer_InternalPB.server_port)
    return server_port_.GetNoArena();
}
inline void LoomServer_InternalPB::set_server_port(const ::std::string& value)
{
    set_has_server_port();
    server_port_.SetNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
    // @@protoc_insertion_point(field_set:opentxs.OTDB.LoomServer_InternalPB.server_port)
}
#if LANG_CXX11
inline void LoomServer_InternalPB::set_server_port(::std::string&& value)
{
    set_has_server_port();
    server_port_.SetNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited(),
        ::std::move(value));
    // @@protoc_insertion_point(field_set_rvalue:opentxs.OTDB.LoomServer_InternalPB.server_port)
}
#endif
inline void LoomServer_InternalPB::set_server_port(const char* value)
{
    GOOGLE_DCHECK(value != NULL);
    set_has_server_port();
    server_port_.SetNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited(),
        ::std::string(value));
    // @@protoc_insertion_point(field_set_char:opentxs.OTDB.LoomServer_InternalPB.server_port)
}
inline void LoomServer_InternalPB::set_server_port(
    const char* value,
    size_t size)
{
    set_has_server_port();
    server_port_.SetNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited(),
        ::std::string(reinterpret_cast<const char*>(value), size));
    // @@protoc_insertion_point(field_set_pointer:opentxs.OTDB.LoomServer_InternalPB.server_port)
}
inline ::std::string* LoomServer_InternalPB::mutable_server_port()
{
    set_has_server_port();
    // @@protoc_insertion_point(field_mutable:opentxs.OTDB.LoomServer_InternalPB.server_port)
    return server_port_.MutableNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* LoomServer_InternalPB::release_server_port()
{
    // @@protoc_insertion_point(field_release:opentxs.OTDB.LoomServer_InternalPB.server_port)
    clear_has_server_port();
    return server_port_.ReleaseNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void LoomServer_InternalPB::set_allocated_server_port(
    ::std::string* server_port)
{
    if (server_port != NULL) {
        set_has_server_port();
    } else {
        clear_has_server_port();
    }
    server_port_.SetAllocatedNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited(),
        server_port);
    // @@protoc_insertion_point(field_set_allocated:opentxs.OTDB.LoomServer_InternalPB.server_port)
}

// optional string loom_username = 6;
inline bool LoomServer_InternalPB::has_loom_username() const
{
    return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void LoomServer_InternalPB::set_has_loom_username()
{
    _has_bits_[0] |= 0x00000020u;
}
inline void LoomServer_InternalPB::clear_has_loom_username()
{
    _has_bits_[0] &= ~0x00000020u;
}
inline void LoomServer_InternalPB::clear_loom_username()
{
    loom_username_.ClearToEmptyNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
    clear_has_loom_username();
}
inline const ::std::string& LoomServer_InternalPB::loom_username() const
{
    // @@protoc_insertion_point(field_get:opentxs.OTDB.LoomServer_InternalPB.loom_username)
    return loom_username_.GetNoArena();
}
inline void LoomServer_InternalPB::set_loom_username(const ::std::string& value)
{
    set_has_loom_username();
    loom_username_.SetNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
    // @@protoc_insertion_point(field_set:opentxs.OTDB.LoomServer_InternalPB.loom_username)
}
#if LANG_CXX11
inline void LoomServer_InternalPB::set_loom_username(::std::string&& value)
{
    set_has_loom_username();
    loom_username_.SetNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited(),
        ::std::move(value));
    // @@protoc_insertion_point(field_set_rvalue:opentxs.OTDB.LoomServer_InternalPB.loom_username)
}
#endif
inline void LoomServer_InternalPB::set_loom_username(const char* value)
{
    GOOGLE_DCHECK(value != NULL);
    set_has_loom_username();
    loom_username_.SetNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited(),
        ::std::string(value));
    // @@protoc_insertion_point(field_set_char:opentxs.OTDB.LoomServer_InternalPB.loom_username)
}
inline void LoomServer_InternalPB::set_loom_username(
    const char* value,
    size_t size)
{
    set_has_loom_username();
    loom_username_.SetNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited(),
        ::std::string(reinterpret_cast<const char*>(value), size));
    // @@protoc_insertion_point(field_set_pointer:opentxs.OTDB.LoomServer_InternalPB.loom_username)
}
inline ::std::string* LoomServer_InternalPB::mutable_loom_username()
{
    set_has_loom_username();
    // @@protoc_insertion_point(field_mutable:opentxs.OTDB.LoomServer_InternalPB.loom_username)
    return loom_username_.MutableNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* LoomServer_InternalPB::release_loom_username()
{
    // @@protoc_insertion_point(field_release:opentxs.OTDB.LoomServer_InternalPB.loom_username)
    clear_has_loom_username();
    return loom_username_.ReleaseNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void LoomServer_InternalPB::set_allocated_loom_username(
    ::std::string* loom_username)
{
    if (loom_username != NULL) {
        set_has_loom_username();
    } else {
        clear_has_loom_username();
    }
    loom_username_.SetAllocatedNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited(),
        loom_username);
    // @@protoc_insertion_point(field_set_allocated:opentxs.OTDB.LoomServer_InternalPB.loom_username)
}

// optional string namefield_id = 7;
inline bool LoomServer_InternalPB::has_namefield_id() const
{
    return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void LoomServer_InternalPB::set_has_namefield_id()
{
    _has_bits_[0] |= 0x00000040u;
}
inline void LoomServer_InternalPB::clear_has_namefield_id()
{
    _has_bits_[0] &= ~0x00000040u;
}
inline void LoomServer_InternalPB::clear_namefield_id()
{
    namefield_id_.ClearToEmptyNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
    clear_has_namefield_id();
}
inline const ::std::string& LoomServer_InternalPB::namefield_id() const
{
    // @@protoc_insertion_point(field_get:opentxs.OTDB.LoomServer_InternalPB.namefield_id)
    return namefield_id_.GetNoArena();
}
inline void LoomServer_InternalPB::set_namefield_id(const ::std::string& value)
{
    set_has_namefield_id();
    namefield_id_.SetNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
    // @@protoc_insertion_point(field_set:opentxs.OTDB.LoomServer_InternalPB.namefield_id)
}
#if LANG_CXX11
inline void LoomServer_InternalPB::set_namefield_id(::std::string&& value)
{
    set_has_namefield_id();
    namefield_id_.SetNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited(),
        ::std::move(value));
    // @@protoc_insertion_point(field_set_rvalue:opentxs.OTDB.LoomServer_InternalPB.namefield_id)
}
#endif
inline void LoomServer_InternalPB::set_namefield_id(const char* value)
{
    GOOGLE_DCHECK(value != NULL);
    set_has_namefield_id();
    namefield_id_.SetNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited(),
        ::std::string(value));
    // @@protoc_insertion_point(field_set_char:opentxs.OTDB.LoomServer_InternalPB.namefield_id)
}
inline void LoomServer_InternalPB::set_namefield_id(
    const char* value,
    size_t size)
{
    set_has_namefield_id();
    namefield_id_.SetNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited(),
        ::std::string(reinterpret_cast<const char*>(value), size));
    // @@protoc_insertion_point(field_set_pointer:opentxs.OTDB.LoomServer_InternalPB.namefield_id)
}
inline ::std::string* LoomServer_InternalPB::mutable_namefield_id()
{
    set_has_namefield_id();
    // @@protoc_insertion_point(field_mutable:opentxs.OTDB.LoomServer_InternalPB.namefield_id)
    return namefield_id_.MutableNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* LoomServer_InternalPB::release_namefield_id()
{
    // @@protoc_insertion_point(field_release:opentxs.OTDB.LoomServer_InternalPB.namefield_id)
    clear_has_namefield_id();
    return namefield_id_.ReleaseNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void LoomServer_InternalPB::set_allocated_namefield_id(
    ::std::string* namefield_id)
{
    if (namefield_id != NULL) {
        set_has_namefield_id();
    } else {
        clear_has_namefield_id();
    }
    namefield_id_.SetAllocatedNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited(),
        namefield_id);
    // @@protoc_insertion_point(field_set_allocated:opentxs.OTDB.LoomServer_InternalPB.namefield_id)
}

#ifdef __GNUC__
#pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// @@protoc_insertion_point(namespace_scope)

}  // namespace OTDB
}  // namespace opentxs

// @@protoc_insertion_point(global_scope)
